// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Boilerplate C++ definitions for a single module.
	This is automatically generated by UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "Private/VRExpansionPluginPrivatePCH.h"
#include "GeneratedCppIncludes.h"
#include "VRExpansionPlugin.generated.dep.h"
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCode1VRExpansionPlugin() {}
FName VREXPANSIONPLUGIN_CanHaveDoubleGrip = FName(TEXT("CanHaveDoubleGrip"));
FName VREXPANSIONPLUGIN_ClosestPrimarySlotInRange = FName(TEXT("ClosestPrimarySlotInRange"));
FName VREXPANSIONPLUGIN_ClosestSecondarySlotInRange = FName(TEXT("ClosestSecondarySlotInRange"));
FName VREXPANSIONPLUGIN_DenyGripping = FName(TEXT("DenyGripping"));
FName VREXPANSIONPLUGIN_FreeGripType = FName(TEXT("FreeGripType"));
FName VREXPANSIONPLUGIN_GetInteractionSettings = FName(TEXT("GetInteractionSettings"));
FName VREXPANSIONPLUGIN_GripBreakDistance = FName(TEXT("GripBreakDistance"));
FName VREXPANSIONPLUGIN_GripDamping = FName(TEXT("GripDamping"));
FName VREXPANSIONPLUGIN_GripLateUpdateSetting = FName(TEXT("GripLateUpdateSetting"));
FName VREXPANSIONPLUGIN_GripMovementReplicationType = FName(TEXT("GripMovementReplicationType"));
FName VREXPANSIONPLUGIN_GripStiffness = FName(TEXT("GripStiffness"));
FName VREXPANSIONPLUGIN_IsInteractible = FName(TEXT("IsInteractible"));
FName VREXPANSIONPLUGIN_NotifyDrop = FName(TEXT("NotifyDrop"));
FName VREXPANSIONPLUGIN_NotifyOfTeleport = FName(TEXT("NotifyOfTeleport"));
FName VREXPANSIONPLUGIN_ObjectType = FName(TEXT("ObjectType"));
FName VREXPANSIONPLUGIN_OnChildGrip = FName(TEXT("OnChildGrip"));
FName VREXPANSIONPLUGIN_OnChildGripRelease = FName(TEXT("OnChildGripRelease"));
FName VREXPANSIONPLUGIN_OnEndUsed = FName(TEXT("OnEndUsed"));
FName VREXPANSIONPLUGIN_OnGrip = FName(TEXT("OnGrip"));
FName VREXPANSIONPLUGIN_OnGripRelease = FName(TEXT("OnGripRelease"));
FName VREXPANSIONPLUGIN_OnSecondaryGrip = FName(TEXT("OnSecondaryGrip"));
FName VREXPANSIONPLUGIN_OnSecondaryGripRelease = FName(TEXT("OnSecondaryGripRelease"));
FName VREXPANSIONPLUGIN_OnUsed = FName(TEXT("OnUsed"));
FName VREXPANSIONPLUGIN_ReceiveNavigationMoveCompleted = FName(TEXT("ReceiveNavigationMoveCompleted"));
FName VREXPANSIONPLUGIN_Server_SendControllerTransform = FName(TEXT("Server_SendControllerTransform"));
FName VREXPANSIONPLUGIN_Server_SendTransform = FName(TEXT("Server_SendTransform"));
FName VREXPANSIONPLUGIN_ServerMoveVR = FName(TEXT("ServerMoveVR"));
FName VREXPANSIONPLUGIN_ServerMoveVRDual = FName(TEXT("ServerMoveVRDual"));
FName VREXPANSIONPLUGIN_ServerMoveVRDualHybridRootMotion = FName(TEXT("ServerMoveVRDualHybridRootMotion"));
FName VREXPANSIONPLUGIN_SimulateOnDrop = FName(TEXT("SimulateOnDrop"));
FName VREXPANSIONPLUGIN_SlotGripType = FName(TEXT("SlotGripType"));
FName VREXPANSIONPLUGIN_TeleportBehavior = FName(TEXT("TeleportBehavior"));
FName VREXPANSIONPLUGIN_TickGrip = FName(TEXT("TickGrip"));
static class UEnum* EGripInterfaceTeleportBehavior_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EGripInterfaceTeleportBehavior"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EGripInterfaceTeleportBehavior(EGripInterfaceTeleportBehavior_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EGripInterfaceTeleportBehavior"), false, nullptr, nullptr);
static class UEnum* EGripTargetType_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripTargetType();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EGripTargetType, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EGripTargetType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EGripTargetType(EGripTargetType_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EGripTargetType"), false, nullptr, nullptr);
static class UEnum* EGripMovementReplicationSettings_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EGripMovementReplicationSettings"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EGripMovementReplicationSettings(EGripMovementReplicationSettings_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EGripMovementReplicationSettings"), false, nullptr, nullptr);
static class UEnum* EGripLateUpdateSettings_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EGripLateUpdateSettings"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EGripLateUpdateSettings(EGripLateUpdateSettings_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EGripLateUpdateSettings"), false, nullptr, nullptr);
static class UEnum* EGripLerpState_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripLerpState();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EGripLerpState, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EGripLerpState"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EGripLerpState(EGripLerpState_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EGripLerpState"), false, nullptr, nullptr);
static class UEnum* EBPHMDDeviceType_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPHMDDeviceType();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EBPHMDDeviceType, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EBPHMDDeviceType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EBPHMDDeviceType(EBPHMDDeviceType_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EBPHMDDeviceType"), false, nullptr, nullptr);
static class UEnum* EGripCollisionType_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EGripCollisionType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EGripCollisionType(EGripCollisionType_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EGripCollisionType"), false, nullptr, nullptr);
static class UEnum* EBPVRResultSwitch_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPVRResultSwitch();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EBPVRResultSwitch, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EBPVRResultSwitch"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EBPVRResultSwitch(EBPVRResultSwitch_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EBPVRResultSwitch"), false, nullptr, nullptr);
static class UEnum* EBPSteamVRTrackedDeviceType_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPSteamVRTrackedDeviceType();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EBPSteamVRTrackedDeviceType, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EBPSteamVRTrackedDeviceType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EBPSteamVRTrackedDeviceType(EBPSteamVRTrackedDeviceType_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EBPSteamVRTrackedDeviceType"), false, nullptr, nullptr);
static class UEnum* EBPTrackingStatus_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPTrackingStatus();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EBPTrackingStatus, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EBPTrackingStatus"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EBPTrackingStatus(EBPTrackingStatus_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EBPTrackingStatus"), false, nullptr, nullptr);
class UScriptStruct* FBPActorPhysicsHandleInformation::StaticStruct()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FBPActorPhysicsHandleInformation();
		extern VREXPANSIONPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FBPActorPhysicsHandleInformation_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FBPActorPhysicsHandleInformation, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("BPActorPhysicsHandleInformation"), sizeof(FBPActorPhysicsHandleInformation), Get_Z_Construct_UScriptStruct_FBPActorPhysicsHandleInformation_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FBPActorPhysicsHandleInformation(FBPActorPhysicsHandleInformation::StaticStruct, TEXT("/Script/VRExpansionPlugin"), TEXT("BPActorPhysicsHandleInformation"), false, nullptr, nullptr);
static struct FScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPActorPhysicsHandleInformation
{
	FScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPActorPhysicsHandleInformation()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("BPActorPhysicsHandleInformation")),new UScriptStruct::TCppStructOps<FBPActorPhysicsHandleInformation>);
	}
} ScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPActorPhysicsHandleInformation;
class UScriptStruct* FBPInterfaceProperties::StaticStruct()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FBPInterfaceProperties();
		extern VREXPANSIONPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FBPInterfaceProperties_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FBPInterfaceProperties, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("BPInterfaceProperties"), sizeof(FBPInterfaceProperties), Get_Z_Construct_UScriptStruct_FBPInterfaceProperties_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FBPInterfaceProperties(FBPInterfaceProperties::StaticStruct, TEXT("/Script/VRExpansionPlugin"), TEXT("BPInterfaceProperties"), false, nullptr, nullptr);
static struct FScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPInterfaceProperties
{
	FScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPInterfaceProperties()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("BPInterfaceProperties")),new UScriptStruct::TCppStructOps<FBPInterfaceProperties>);
	}
} ScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPInterfaceProperties;
class UScriptStruct* FBPActorGripInformation::StaticStruct()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FBPActorGripInformation();
		extern VREXPANSIONPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FBPActorGripInformation_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FBPActorGripInformation, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("BPActorGripInformation"), sizeof(FBPActorGripInformation), Get_Z_Construct_UScriptStruct_FBPActorGripInformation_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FBPActorGripInformation(FBPActorGripInformation::StaticStruct, TEXT("/Script/VRExpansionPlugin"), TEXT("BPActorGripInformation"), false, nullptr, nullptr);
static struct FScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPActorGripInformation
{
	FScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPActorGripInformation()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("BPActorGripInformation")),new UScriptStruct::TCppStructOps<FBPActorGripInformation>);
	}
} ScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPActorGripInformation;
class UScriptStruct* FBPInteractionSettings::StaticStruct()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FBPInteractionSettings();
		extern VREXPANSIONPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FBPInteractionSettings_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FBPInteractionSettings, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("BPInteractionSettings"), sizeof(FBPInteractionSettings), Get_Z_Construct_UScriptStruct_FBPInteractionSettings_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FBPInteractionSettings(FBPInteractionSettings::StaticStruct, TEXT("/Script/VRExpansionPlugin"), TEXT("BPInteractionSettings"), false, nullptr, nullptr);
static struct FScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPInteractionSettings
{
	FScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPInteractionSettings()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("BPInteractionSettings")),new UScriptStruct::TCppStructOps<FBPInteractionSettings>);
	}
} ScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPInteractionSettings;
class UScriptStruct* FBPVRComponentPosRep::StaticStruct()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FBPVRComponentPosRep();
		extern VREXPANSIONPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FBPVRComponentPosRep_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FBPVRComponentPosRep, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("BPVRComponentPosRep"), sizeof(FBPVRComponentPosRep), Get_Z_Construct_UScriptStruct_FBPVRComponentPosRep_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FBPVRComponentPosRep(FBPVRComponentPosRep::StaticStruct, TEXT("/Script/VRExpansionPlugin"), TEXT("BPVRComponentPosRep"), false, nullptr, nullptr);
static struct FScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPVRComponentPosRep
{
	FScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPVRComponentPosRep()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("BPVRComponentPosRep")),new UScriptStruct::TCppStructOps<FBPVRComponentPosRep>);
	}
} ScriptStruct_VRExpansionPlugin_StaticRegisterNativesFBPVRComponentPosRep;
	bool IVRGripInterface::CanHaveDoubleGrip()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_CanHaveDoubleGrip instead.");
		VRGripInterface_eventCanHaveDoubleGrip_Parms Parms;
		return Parms.ReturnValue;
	}
	void IVRGripInterface::ClosestPrimarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_ClosestPrimarySlotInRange instead.");
	}
	void IVRGripInterface::ClosestSecondarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_ClosestSecondarySlotInRange instead.");
	}
	bool IVRGripInterface::DenyGripping()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_DenyGripping instead.");
		VRGripInterface_eventDenyGripping_Parms Parms;
		return Parms.ReturnValue;
	}
	EGripCollisionType IVRGripInterface::FreeGripType()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_FreeGripType instead.");
		VRGripInterface_eventFreeGripType_Parms Parms;
		return Parms.ReturnValue;
	}
	FBPInteractionSettings IVRGripInterface::GetInteractionSettings()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetInteractionSettings instead.");
		VRGripInterface_eventGetInteractionSettings_Parms Parms;
		return Parms.ReturnValue;
	}
	float IVRGripInterface::GripBreakDistance()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GripBreakDistance instead.");
		VRGripInterface_eventGripBreakDistance_Parms Parms;
		return Parms.ReturnValue;
	}
	float IVRGripInterface::GripDamping()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GripDamping instead.");
		VRGripInterface_eventGripDamping_Parms Parms;
		return Parms.ReturnValue;
	}
	EGripLateUpdateSettings IVRGripInterface::GripLateUpdateSetting()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GripLateUpdateSetting instead.");
		VRGripInterface_eventGripLateUpdateSetting_Parms Parms;
		return Parms.ReturnValue;
	}
	EGripMovementReplicationSettings IVRGripInterface::GripMovementReplicationType()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GripMovementReplicationType instead.");
		VRGripInterface_eventGripMovementReplicationType_Parms Parms;
		return Parms.ReturnValue;
	}
	float IVRGripInterface::GripStiffness()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GripStiffness instead.");
		VRGripInterface_eventGripStiffness_Parms Parms;
		return Parms.ReturnValue;
	}
	bool IVRGripInterface::IsInteractible()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_IsInteractible instead.");
		VRGripInterface_eventIsInteractible_Parms Parms;
		return Parms.ReturnValue;
	}
	void IVRGripInterface::ObjectType(uint8& ObjectType)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_ObjectType instead.");
	}
	void IVRGripInterface::OnChildGrip(UGripMotionControllerComponent* GrippingController, FBPActorGripInformation const& GripInformation)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnChildGrip instead.");
	}
	void IVRGripInterface::OnChildGripRelease(UGripMotionControllerComponent* ReleasingController, FBPActorGripInformation const& GripInformation)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnChildGripRelease instead.");
	}
	void IVRGripInterface::OnEndUsed()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnEndUsed instead.");
	}
	void IVRGripInterface::OnGrip(UGripMotionControllerComponent* GrippingController, FBPActorGripInformation const& GripInformation)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnGrip instead.");
	}
	void IVRGripInterface::OnGripRelease(UGripMotionControllerComponent* ReleasingController, FBPActorGripInformation const& GripInformation)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnGripRelease instead.");
	}
	void IVRGripInterface::OnSecondaryGrip(USceneComponent* SecondaryGripComponent, FBPActorGripInformation const& GripInformation)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnSecondaryGrip instead.");
	}
	void IVRGripInterface::OnSecondaryGripRelease(USceneComponent* ReleasingSecondaryGripComponent, FBPActorGripInformation const& GripInformation)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnSecondaryGripRelease instead.");
	}
	void IVRGripInterface::OnUsed()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnUsed instead.");
	}
	bool IVRGripInterface::SimulateOnDrop()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_SimulateOnDrop instead.");
		VRGripInterface_eventSimulateOnDrop_Parms Parms;
		return Parms.ReturnValue;
	}
	EGripCollisionType IVRGripInterface::SlotGripType()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_SlotGripType instead.");
		VRGripInterface_eventSlotGripType_Parms Parms;
		return Parms.ReturnValue;
	}
	EGripInterfaceTeleportBehavior IVRGripInterface::TeleportBehavior()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_TeleportBehavior instead.");
		VRGripInterface_eventTeleportBehavior_Parms Parms;
		return Parms.ReturnValue;
	}
	void IVRGripInterface::TickGrip(UGripMotionControllerComponent* GrippingController, FBPActorGripInformation const& GripInformation, FVector MControllerLocDelta, float DeltaTime)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_TickGrip instead.");
	}
	void UVRGripInterface::StaticRegisterNativesUVRGripInterface()
	{
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "CanHaveDoubleGrip",(Native)&IVRGripInterface::execCanHaveDoubleGrip);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "ClosestPrimarySlotInRange",(Native)&IVRGripInterface::execClosestPrimarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "ClosestSecondarySlotInRange",(Native)&IVRGripInterface::execClosestSecondarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "DenyGripping",(Native)&IVRGripInterface::execDenyGripping);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "FreeGripType",(Native)&IVRGripInterface::execFreeGripType);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "GetInteractionSettings",(Native)&IVRGripInterface::execGetInteractionSettings);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "GripBreakDistance",(Native)&IVRGripInterface::execGripBreakDistance);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "GripDamping",(Native)&IVRGripInterface::execGripDamping);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "GripLateUpdateSetting",(Native)&IVRGripInterface::execGripLateUpdateSetting);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "GripMovementReplicationType",(Native)&IVRGripInterface::execGripMovementReplicationType);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "GripStiffness",(Native)&IVRGripInterface::execGripStiffness);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "IsInteractible",(Native)&IVRGripInterface::execIsInteractible);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "ObjectType",(Native)&IVRGripInterface::execObjectType);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "SimulateOnDrop",(Native)&IVRGripInterface::execSimulateOnDrop);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "SlotGripType",(Native)&IVRGripInterface::execSlotGripType);
		FNativeFunctionRegistrar::RegisterFunction(UVRGripInterface::StaticClass(), "TeleportBehavior",(Native)&IVRGripInterface::execTeleportBehavior);
	}
	IMPLEMENT_CLASS(UVRGripInterface, 4237398121);
	bool IVRGripInterface::Execute_CanHaveDoubleGrip(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventCanHaveDoubleGrip_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_CanHaveDoubleGrip);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->CanHaveDoubleGrip_Implementation();
		}
		return Parms.ReturnValue;
	}
	void IVRGripInterface::Execute_ClosestPrimarySlotInRange(UObject* O, FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventClosestPrimarySlotInRange_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_ClosestPrimarySlotInRange);
		if (Func)
		{
			Parms.WorldLocation=WorldLocation;
			Parms.bHadSlotInRange=bHadSlotInRange;
			Parms.SlotWorldTransform=SlotWorldTransform;
			O->ProcessEvent(Func, &Parms);
			bHadSlotInRange=Parms.bHadSlotInRange;
			SlotWorldTransform=Parms.SlotWorldTransform;
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->ClosestPrimarySlotInRange_Implementation(WorldLocation,bHadSlotInRange,SlotWorldTransform);
		}
	}
	void IVRGripInterface::Execute_ClosestSecondarySlotInRange(UObject* O, FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventClosestSecondarySlotInRange_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_ClosestSecondarySlotInRange);
		if (Func)
		{
			Parms.WorldLocation=WorldLocation;
			Parms.bHadSlotInRange=bHadSlotInRange;
			Parms.SlotWorldTransform=SlotWorldTransform;
			O->ProcessEvent(Func, &Parms);
			bHadSlotInRange=Parms.bHadSlotInRange;
			SlotWorldTransform=Parms.SlotWorldTransform;
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->ClosestSecondarySlotInRange_Implementation(WorldLocation,bHadSlotInRange,SlotWorldTransform);
		}
	}
	bool IVRGripInterface::Execute_DenyGripping(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventDenyGripping_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_DenyGripping);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->DenyGripping_Implementation();
		}
		return Parms.ReturnValue;
	}
	EGripCollisionType IVRGripInterface::Execute_FreeGripType(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventFreeGripType_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_FreeGripType);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->FreeGripType_Implementation();
		}
		return Parms.ReturnValue;
	}
	FBPInteractionSettings IVRGripInterface::Execute_GetInteractionSettings(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventGetInteractionSettings_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_GetInteractionSettings);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->GetInteractionSettings_Implementation();
		}
		return Parms.ReturnValue;
	}
	float IVRGripInterface::Execute_GripBreakDistance(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventGripBreakDistance_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_GripBreakDistance);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->GripBreakDistance_Implementation();
		}
		return Parms.ReturnValue;
	}
	float IVRGripInterface::Execute_GripDamping(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventGripDamping_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_GripDamping);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->GripDamping_Implementation();
		}
		return Parms.ReturnValue;
	}
	EGripLateUpdateSettings IVRGripInterface::Execute_GripLateUpdateSetting(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventGripLateUpdateSetting_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_GripLateUpdateSetting);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->GripLateUpdateSetting_Implementation();
		}
		return Parms.ReturnValue;
	}
	EGripMovementReplicationSettings IVRGripInterface::Execute_GripMovementReplicationType(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventGripMovementReplicationType_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_GripMovementReplicationType);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->GripMovementReplicationType_Implementation();
		}
		return Parms.ReturnValue;
	}
	float IVRGripInterface::Execute_GripStiffness(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventGripStiffness_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_GripStiffness);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->GripStiffness_Implementation();
		}
		return Parms.ReturnValue;
	}
	bool IVRGripInterface::Execute_IsInteractible(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventIsInteractible_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_IsInteractible);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->IsInteractible_Implementation();
		}
		return Parms.ReturnValue;
	}
	void IVRGripInterface::Execute_ObjectType(UObject* O, uint8& ObjectType)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventObjectType_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_ObjectType);
		if (Func)
		{
			Parms.ObjectType=ObjectType;
			O->ProcessEvent(Func, &Parms);
			ObjectType=Parms.ObjectType;
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->ObjectType_Implementation(ObjectType);
		}
	}
	void IVRGripInterface::Execute_OnChildGrip(UObject* O, UGripMotionControllerComponent* GrippingController, FBPActorGripInformation const& GripInformation)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventOnChildGrip_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_OnChildGrip);
		if (Func)
		{
			Parms.GrippingController=GrippingController;
			Parms.GripInformation=GripInformation;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IVRGripInterface::Execute_OnChildGripRelease(UObject* O, UGripMotionControllerComponent* ReleasingController, FBPActorGripInformation const& GripInformation)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventOnChildGripRelease_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_OnChildGripRelease);
		if (Func)
		{
			Parms.ReleasingController=ReleasingController;
			Parms.GripInformation=GripInformation;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IVRGripInterface::Execute_OnEndUsed(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_OnEndUsed);
		if (Func)
		{
			O->ProcessEvent(Func, NULL);
		}
	}
	void IVRGripInterface::Execute_OnGrip(UObject* O, UGripMotionControllerComponent* GrippingController, FBPActorGripInformation const& GripInformation)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventOnGrip_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_OnGrip);
		if (Func)
		{
			Parms.GrippingController=GrippingController;
			Parms.GripInformation=GripInformation;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IVRGripInterface::Execute_OnGripRelease(UObject* O, UGripMotionControllerComponent* ReleasingController, FBPActorGripInformation const& GripInformation)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventOnGripRelease_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_OnGripRelease);
		if (Func)
		{
			Parms.ReleasingController=ReleasingController;
			Parms.GripInformation=GripInformation;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IVRGripInterface::Execute_OnSecondaryGrip(UObject* O, USceneComponent* SecondaryGripComponent, FBPActorGripInformation const& GripInformation)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventOnSecondaryGrip_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_OnSecondaryGrip);
		if (Func)
		{
			Parms.SecondaryGripComponent=SecondaryGripComponent;
			Parms.GripInformation=GripInformation;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IVRGripInterface::Execute_OnSecondaryGripRelease(UObject* O, USceneComponent* ReleasingSecondaryGripComponent, FBPActorGripInformation const& GripInformation)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventOnSecondaryGripRelease_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_OnSecondaryGripRelease);
		if (Func)
		{
			Parms.ReleasingSecondaryGripComponent=ReleasingSecondaryGripComponent;
			Parms.GripInformation=GripInformation;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IVRGripInterface::Execute_OnUsed(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_OnUsed);
		if (Func)
		{
			O->ProcessEvent(Func, NULL);
		}
	}
	bool IVRGripInterface::Execute_SimulateOnDrop(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventSimulateOnDrop_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_SimulateOnDrop);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->SimulateOnDrop_Implementation();
		}
		return Parms.ReturnValue;
	}
	EGripCollisionType IVRGripInterface::Execute_SlotGripType(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventSlotGripType_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_SlotGripType);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->SlotGripType_Implementation();
		}
		return Parms.ReturnValue;
	}
	EGripInterfaceTeleportBehavior IVRGripInterface::Execute_TeleportBehavior(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventTeleportBehavior_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_TeleportBehavior);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->TeleportBehavior_Implementation();
		}
		return Parms.ReturnValue;
	}
	void IVRGripInterface::Execute_TickGrip(UObject* O, UGripMotionControllerComponent* GrippingController, FBPActorGripInformation const& GripInformation, FVector MControllerLocDelta, float DeltaTime)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventTickGrip_Parms Parms;
		UFunction* const Func = O->FindFunction(VREXPANSIONPLUGIN_TickGrip);
		if (Func)
		{
			Parms.GrippingController=GrippingController;
			Parms.GripInformation=GripInformation;
			Parms.MControllerLocDelta=MControllerLocDelta;
			Parms.DeltaTime=DeltaTime;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void UGripMotionControllerComponent::NotifyDrop(FBPActorGripInformation const& NewDrop, bool bSimulate)
	{
		GripMotionControllerComponent_eventNotifyDrop_Parms Parms;
		Parms.NewDrop=NewDrop;
		Parms.bSimulate=bSimulate ? true : false;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_NotifyDrop),&Parms);
	}
	void UGripMotionControllerComponent::Server_SendControllerTransform(FBPVRComponentPosRep NewTransform)
	{
		GripMotionControllerComponent_eventServer_SendControllerTransform_Parms Parms;
		Parms.NewTransform=NewTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_Server_SendControllerTransform),&Parms);
	}
	void UGripMotionControllerComponent::StaticRegisterNativesUGripMotionControllerComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "AddSecondaryAttachmentPoint",(Native)&UGripMotionControllerComponent::execAddSecondaryAttachmentPoint);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "ConvertToControllerRelativeTransform",(Native)&UGripMotionControllerComponent::execConvertToControllerRelativeTransform);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "ConvertToGripRelativeTransform",(Native)&UGripMotionControllerComponent::execConvertToGripRelativeTransform);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "CreateGripRelativeAdditionTransform_BP",(Native)&UGripMotionControllerComponent::execCreateGripRelativeAdditionTransform_BP);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "DropActor",(Native)&UGripMotionControllerComponent::execDropActor);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "DropComponent",(Native)&UGripMotionControllerComponent::execDropComponent);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "DropGrip",(Native)&UGripMotionControllerComponent::execDropGrip);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "DropObject",(Native)&UGripMotionControllerComponent::execDropObject);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "DropObjectByInterface",(Native)&UGripMotionControllerComponent::execDropObjectByInterface);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GetGripByActor",(Native)&UGripMotionControllerComponent::execGetGripByActor);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GetGripByComponent",(Native)&UGripMotionControllerComponent::execGetGripByComponent);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GetGrippedActors",(Native)&UGripMotionControllerComponent::execGetGrippedActors);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GetGrippedComponents",(Native)&UGripMotionControllerComponent::execGetGrippedComponents);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GetIsComponentHeld",(Native)&UGripMotionControllerComponent::execGetIsComponentHeld);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GetIsHeld",(Native)&UGripMotionControllerComponent::execGetIsHeld);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GetIsObjectHeld",(Native)&UGripMotionControllerComponent::execGetIsObjectHeld);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GetIsSecondaryAttachment",(Native)&UGripMotionControllerComponent::execGetIsSecondaryAttachment);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GetPhysicsVelocities",(Native)&UGripMotionControllerComponent::execGetPhysicsVelocities);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GripActor",(Native)&UGripMotionControllerComponent::execGripActor);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GripComponent",(Native)&UGripMotionControllerComponent::execGripComponent);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GripObject",(Native)&UGripMotionControllerComponent::execGripObject);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "GripObjectByInterface",(Native)&UGripMotionControllerComponent::execGripObjectByInterface);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "IsTracked",(Native)&UGripMotionControllerComponent::execIsTracked);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "NotifyDrop",(Native)&UGripMotionControllerComponent::execNotifyDrop);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "OnRep_GrippedActors",(Native)&UGripMotionControllerComponent::execOnRep_GrippedActors);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "OnRep_ReplicatedControllerTransform",(Native)&UGripMotionControllerComponent::execOnRep_ReplicatedControllerTransform);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "PostTeleportMoveGrippedActors",(Native)&UGripMotionControllerComponent::execPostTeleportMoveGrippedActors);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "RemoveSecondaryAttachmentPoint",(Native)&UGripMotionControllerComponent::execRemoveSecondaryAttachmentPoint);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "Server_SendControllerTransform",(Native)&UGripMotionControllerComponent::execServer_SendControllerTransform);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "SetGripAdditionTransform",(Native)&UGripMotionControllerComponent::execSetGripAdditionTransform);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "SetGripLateUpdateSetting",(Native)&UGripMotionControllerComponent::execSetGripLateUpdateSetting);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "SetGripRelativeTransform",(Native)&UGripMotionControllerComponent::execSetGripRelativeTransform);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "TeleportMoveGrip",(Native)&UGripMotionControllerComponent::execTeleportMoveGrip);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "TeleportMoveGrippedActor",(Native)&UGripMotionControllerComponent::execTeleportMoveGrippedActor);
		FNativeFunctionRegistrar::RegisterFunction(UGripMotionControllerComponent::StaticClass(), "TeleportMoveGrippedComponent",(Native)&UGripMotionControllerComponent::execTeleportMoveGrippedComponent);
	}
	IMPLEMENT_CLASS(UGripMotionControllerComponent, 3108175689);
	bool UGrippableBoxComponent::CanHaveDoubleGrip()
	{
		GrippableBoxComponent_eventCanHaveDoubleGrip_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_CanHaveDoubleGrip),&Parms);
		return !!Parms.ReturnValue;
	}
	void UGrippableBoxComponent::ClosestPrimarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableBoxComponent_eventClosestPrimarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestPrimarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	void UGrippableBoxComponent::ClosestSecondarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableBoxComponent_eventClosestSecondarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestSecondarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	bool UGrippableBoxComponent::DenyGripping()
	{
		GrippableBoxComponent_eventDenyGripping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_DenyGripping),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType UGrippableBoxComponent::FreeGripType()
	{
		GrippableBoxComponent_eventFreeGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_FreeGripType),&Parms);
		return Parms.ReturnValue;
	}
	FBPInteractionSettings UGrippableBoxComponent::GetInteractionSettings()
	{
		GrippableBoxComponent_eventGetInteractionSettings_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GetInteractionSettings),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableBoxComponent::GripBreakDistance()
	{
		GrippableBoxComponent_eventGripBreakDistance_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripBreakDistance),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableBoxComponent::GripDamping()
	{
		GrippableBoxComponent_eventGripDamping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripDamping),&Parms);
		return Parms.ReturnValue;
	}
	EGripLateUpdateSettings UGrippableBoxComponent::GripLateUpdateSetting()
	{
		GrippableBoxComponent_eventGripLateUpdateSetting_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripLateUpdateSetting),&Parms);
		return Parms.ReturnValue;
	}
	EGripMovementReplicationSettings UGrippableBoxComponent::GripMovementReplicationType()
	{
		GrippableBoxComponent_eventGripMovementReplicationType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripMovementReplicationType),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableBoxComponent::GripStiffness()
	{
		GrippableBoxComponent_eventGripStiffness_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripStiffness),&Parms);
		return Parms.ReturnValue;
	}
	bool UGrippableBoxComponent::IsInteractible()
	{
		GrippableBoxComponent_eventIsInteractible_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_IsInteractible),&Parms);
		return !!Parms.ReturnValue;
	}
	void UGrippableBoxComponent::ObjectType(uint8& ObjectType)
	{
		GrippableBoxComponent_eventObjectType_Parms Parms;
		Parms.ObjectType=ObjectType;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ObjectType),&Parms);
		ObjectType=Parms.ObjectType;
	}
	bool UGrippableBoxComponent::SimulateOnDrop()
	{
		GrippableBoxComponent_eventSimulateOnDrop_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SimulateOnDrop),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType UGrippableBoxComponent::SlotGripType()
	{
		GrippableBoxComponent_eventSlotGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SlotGripType),&Parms);
		return Parms.ReturnValue;
	}
	EGripInterfaceTeleportBehavior UGrippableBoxComponent::TeleportBehavior()
	{
		GrippableBoxComponent_eventTeleportBehavior_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_TeleportBehavior),&Parms);
		return Parms.ReturnValue;
	}
	void UGrippableBoxComponent::StaticRegisterNativesUGrippableBoxComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "CanHaveDoubleGrip",(Native)&UGrippableBoxComponent::execCanHaveDoubleGrip);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "ClosestPrimarySlotInRange",(Native)&UGrippableBoxComponent::execClosestPrimarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "ClosestSecondarySlotInRange",(Native)&UGrippableBoxComponent::execClosestSecondarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "DenyGripping",(Native)&UGrippableBoxComponent::execDenyGripping);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "FreeGripType",(Native)&UGrippableBoxComponent::execFreeGripType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "GetInteractionSettings",(Native)&UGrippableBoxComponent::execGetInteractionSettings);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "GripBreakDistance",(Native)&UGrippableBoxComponent::execGripBreakDistance);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "GripDamping",(Native)&UGrippableBoxComponent::execGripDamping);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "GripLateUpdateSetting",(Native)&UGrippableBoxComponent::execGripLateUpdateSetting);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "GripMovementReplicationType",(Native)&UGrippableBoxComponent::execGripMovementReplicationType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "GripStiffness",(Native)&UGrippableBoxComponent::execGripStiffness);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "IsInteractible",(Native)&UGrippableBoxComponent::execIsInteractible);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "ObjectType",(Native)&UGrippableBoxComponent::execObjectType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "SimulateOnDrop",(Native)&UGrippableBoxComponent::execSimulateOnDrop);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "SlotGripType",(Native)&UGrippableBoxComponent::execSlotGripType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableBoxComponent::StaticClass(), "TeleportBehavior",(Native)&UGrippableBoxComponent::execTeleportBehavior);
	}
	IMPLEMENT_CLASS(UGrippableBoxComponent, 4290180690);
	bool UGrippableCapsuleComponent::CanHaveDoubleGrip()
	{
		GrippableCapsuleComponent_eventCanHaveDoubleGrip_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_CanHaveDoubleGrip),&Parms);
		return !!Parms.ReturnValue;
	}
	void UGrippableCapsuleComponent::ClosestPrimarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableCapsuleComponent_eventClosestPrimarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestPrimarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	void UGrippableCapsuleComponent::ClosestSecondarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableCapsuleComponent_eventClosestSecondarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestSecondarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	bool UGrippableCapsuleComponent::DenyGripping()
	{
		GrippableCapsuleComponent_eventDenyGripping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_DenyGripping),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType UGrippableCapsuleComponent::FreeGripType()
	{
		GrippableCapsuleComponent_eventFreeGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_FreeGripType),&Parms);
		return Parms.ReturnValue;
	}
	FBPInteractionSettings UGrippableCapsuleComponent::GetInteractionSettings()
	{
		GrippableCapsuleComponent_eventGetInteractionSettings_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GetInteractionSettings),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableCapsuleComponent::GripBreakDistance()
	{
		GrippableCapsuleComponent_eventGripBreakDistance_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripBreakDistance),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableCapsuleComponent::GripDamping()
	{
		GrippableCapsuleComponent_eventGripDamping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripDamping),&Parms);
		return Parms.ReturnValue;
	}
	EGripLateUpdateSettings UGrippableCapsuleComponent::GripLateUpdateSetting()
	{
		GrippableCapsuleComponent_eventGripLateUpdateSetting_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripLateUpdateSetting),&Parms);
		return Parms.ReturnValue;
	}
	EGripMovementReplicationSettings UGrippableCapsuleComponent::GripMovementReplicationType()
	{
		GrippableCapsuleComponent_eventGripMovementReplicationType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripMovementReplicationType),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableCapsuleComponent::GripStiffness()
	{
		GrippableCapsuleComponent_eventGripStiffness_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripStiffness),&Parms);
		return Parms.ReturnValue;
	}
	bool UGrippableCapsuleComponent::IsInteractible()
	{
		GrippableCapsuleComponent_eventIsInteractible_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_IsInteractible),&Parms);
		return !!Parms.ReturnValue;
	}
	void UGrippableCapsuleComponent::ObjectType(uint8& ObjectType)
	{
		GrippableCapsuleComponent_eventObjectType_Parms Parms;
		Parms.ObjectType=ObjectType;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ObjectType),&Parms);
		ObjectType=Parms.ObjectType;
	}
	bool UGrippableCapsuleComponent::SimulateOnDrop()
	{
		GrippableCapsuleComponent_eventSimulateOnDrop_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SimulateOnDrop),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType UGrippableCapsuleComponent::SlotGripType()
	{
		GrippableCapsuleComponent_eventSlotGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SlotGripType),&Parms);
		return Parms.ReturnValue;
	}
	EGripInterfaceTeleportBehavior UGrippableCapsuleComponent::TeleportBehavior()
	{
		GrippableCapsuleComponent_eventTeleportBehavior_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_TeleportBehavior),&Parms);
		return Parms.ReturnValue;
	}
	void UGrippableCapsuleComponent::StaticRegisterNativesUGrippableCapsuleComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "CanHaveDoubleGrip",(Native)&UGrippableCapsuleComponent::execCanHaveDoubleGrip);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "ClosestPrimarySlotInRange",(Native)&UGrippableCapsuleComponent::execClosestPrimarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "ClosestSecondarySlotInRange",(Native)&UGrippableCapsuleComponent::execClosestSecondarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "DenyGripping",(Native)&UGrippableCapsuleComponent::execDenyGripping);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "FreeGripType",(Native)&UGrippableCapsuleComponent::execFreeGripType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "GetInteractionSettings",(Native)&UGrippableCapsuleComponent::execGetInteractionSettings);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "GripBreakDistance",(Native)&UGrippableCapsuleComponent::execGripBreakDistance);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "GripDamping",(Native)&UGrippableCapsuleComponent::execGripDamping);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "GripLateUpdateSetting",(Native)&UGrippableCapsuleComponent::execGripLateUpdateSetting);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "GripMovementReplicationType",(Native)&UGrippableCapsuleComponent::execGripMovementReplicationType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "GripStiffness",(Native)&UGrippableCapsuleComponent::execGripStiffness);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "IsInteractible",(Native)&UGrippableCapsuleComponent::execIsInteractible);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "ObjectType",(Native)&UGrippableCapsuleComponent::execObjectType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "SimulateOnDrop",(Native)&UGrippableCapsuleComponent::execSimulateOnDrop);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "SlotGripType",(Native)&UGrippableCapsuleComponent::execSlotGripType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableCapsuleComponent::StaticClass(), "TeleportBehavior",(Native)&UGrippableCapsuleComponent::execTeleportBehavior);
	}
	IMPLEMENT_CLASS(UGrippableCapsuleComponent, 1161094715);
	bool AGrippableSkeletalMeshActor::CanHaveDoubleGrip()
	{
		GrippableSkeletalMeshActor_eventCanHaveDoubleGrip_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_CanHaveDoubleGrip),&Parms);
		return !!Parms.ReturnValue;
	}
	void AGrippableSkeletalMeshActor::ClosestPrimarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableSkeletalMeshActor_eventClosestPrimarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestPrimarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	void AGrippableSkeletalMeshActor::ClosestSecondarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableSkeletalMeshActor_eventClosestSecondarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestSecondarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	bool AGrippableSkeletalMeshActor::DenyGripping()
	{
		GrippableSkeletalMeshActor_eventDenyGripping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_DenyGripping),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType AGrippableSkeletalMeshActor::FreeGripType()
	{
		GrippableSkeletalMeshActor_eventFreeGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_FreeGripType),&Parms);
		return Parms.ReturnValue;
	}
	FBPInteractionSettings AGrippableSkeletalMeshActor::GetInteractionSettings()
	{
		GrippableSkeletalMeshActor_eventGetInteractionSettings_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GetInteractionSettings),&Parms);
		return Parms.ReturnValue;
	}
	float AGrippableSkeletalMeshActor::GripBreakDistance()
	{
		GrippableSkeletalMeshActor_eventGripBreakDistance_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripBreakDistance),&Parms);
		return Parms.ReturnValue;
	}
	float AGrippableSkeletalMeshActor::GripDamping()
	{
		GrippableSkeletalMeshActor_eventGripDamping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripDamping),&Parms);
		return Parms.ReturnValue;
	}
	EGripLateUpdateSettings AGrippableSkeletalMeshActor::GripLateUpdateSetting()
	{
		GrippableSkeletalMeshActor_eventGripLateUpdateSetting_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripLateUpdateSetting),&Parms);
		return Parms.ReturnValue;
	}
	EGripMovementReplicationSettings AGrippableSkeletalMeshActor::GripMovementReplicationType()
	{
		GrippableSkeletalMeshActor_eventGripMovementReplicationType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripMovementReplicationType),&Parms);
		return Parms.ReturnValue;
	}
	float AGrippableSkeletalMeshActor::GripStiffness()
	{
		GrippableSkeletalMeshActor_eventGripStiffness_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripStiffness),&Parms);
		return Parms.ReturnValue;
	}
	bool AGrippableSkeletalMeshActor::IsInteractible()
	{
		GrippableSkeletalMeshActor_eventIsInteractible_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_IsInteractible),&Parms);
		return !!Parms.ReturnValue;
	}
	void AGrippableSkeletalMeshActor::ObjectType(uint8& ObjectType)
	{
		GrippableSkeletalMeshActor_eventObjectType_Parms Parms;
		Parms.ObjectType=ObjectType;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ObjectType),&Parms);
		ObjectType=Parms.ObjectType;
	}
	bool AGrippableSkeletalMeshActor::SimulateOnDrop()
	{
		GrippableSkeletalMeshActor_eventSimulateOnDrop_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SimulateOnDrop),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType AGrippableSkeletalMeshActor::SlotGripType()
	{
		GrippableSkeletalMeshActor_eventSlotGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SlotGripType),&Parms);
		return Parms.ReturnValue;
	}
	EGripInterfaceTeleportBehavior AGrippableSkeletalMeshActor::TeleportBehavior()
	{
		GrippableSkeletalMeshActor_eventTeleportBehavior_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_TeleportBehavior),&Parms);
		return Parms.ReturnValue;
	}
	void AGrippableSkeletalMeshActor::StaticRegisterNativesAGrippableSkeletalMeshActor()
	{
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "CanHaveDoubleGrip",(Native)&AGrippableSkeletalMeshActor::execCanHaveDoubleGrip);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "ClosestPrimarySlotInRange",(Native)&AGrippableSkeletalMeshActor::execClosestPrimarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "ClosestSecondarySlotInRange",(Native)&AGrippableSkeletalMeshActor::execClosestSecondarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "DenyGripping",(Native)&AGrippableSkeletalMeshActor::execDenyGripping);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "FreeGripType",(Native)&AGrippableSkeletalMeshActor::execFreeGripType);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "GetInteractionSettings",(Native)&AGrippableSkeletalMeshActor::execGetInteractionSettings);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "GripBreakDistance",(Native)&AGrippableSkeletalMeshActor::execGripBreakDistance);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "GripDamping",(Native)&AGrippableSkeletalMeshActor::execGripDamping);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "GripLateUpdateSetting",(Native)&AGrippableSkeletalMeshActor::execGripLateUpdateSetting);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "GripMovementReplicationType",(Native)&AGrippableSkeletalMeshActor::execGripMovementReplicationType);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "GripStiffness",(Native)&AGrippableSkeletalMeshActor::execGripStiffness);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "IsInteractible",(Native)&AGrippableSkeletalMeshActor::execIsInteractible);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "ObjectType",(Native)&AGrippableSkeletalMeshActor::execObjectType);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "SimulateOnDrop",(Native)&AGrippableSkeletalMeshActor::execSimulateOnDrop);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "SlotGripType",(Native)&AGrippableSkeletalMeshActor::execSlotGripType);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableSkeletalMeshActor::StaticClass(), "TeleportBehavior",(Native)&AGrippableSkeletalMeshActor::execTeleportBehavior);
	}
	IMPLEMENT_CLASS(AGrippableSkeletalMeshActor, 1336586346);
	bool UGrippableSkeletalMeshComponent::CanHaveDoubleGrip()
	{
		GrippableSkeletalMeshComponent_eventCanHaveDoubleGrip_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_CanHaveDoubleGrip),&Parms);
		return !!Parms.ReturnValue;
	}
	void UGrippableSkeletalMeshComponent::ClosestPrimarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableSkeletalMeshComponent_eventClosestPrimarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestPrimarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	void UGrippableSkeletalMeshComponent::ClosestSecondarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableSkeletalMeshComponent_eventClosestSecondarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestSecondarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	bool UGrippableSkeletalMeshComponent::DenyGripping()
	{
		GrippableSkeletalMeshComponent_eventDenyGripping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_DenyGripping),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType UGrippableSkeletalMeshComponent::FreeGripType()
	{
		GrippableSkeletalMeshComponent_eventFreeGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_FreeGripType),&Parms);
		return Parms.ReturnValue;
	}
	FBPInteractionSettings UGrippableSkeletalMeshComponent::GetInteractionSettings()
	{
		GrippableSkeletalMeshComponent_eventGetInteractionSettings_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GetInteractionSettings),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableSkeletalMeshComponent::GripBreakDistance()
	{
		GrippableSkeletalMeshComponent_eventGripBreakDistance_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripBreakDistance),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableSkeletalMeshComponent::GripDamping()
	{
		GrippableSkeletalMeshComponent_eventGripDamping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripDamping),&Parms);
		return Parms.ReturnValue;
	}
	EGripLateUpdateSettings UGrippableSkeletalMeshComponent::GripLateUpdateSetting()
	{
		GrippableSkeletalMeshComponent_eventGripLateUpdateSetting_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripLateUpdateSetting),&Parms);
		return Parms.ReturnValue;
	}
	EGripMovementReplicationSettings UGrippableSkeletalMeshComponent::GripMovementReplicationType()
	{
		GrippableSkeletalMeshComponent_eventGripMovementReplicationType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripMovementReplicationType),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableSkeletalMeshComponent::GripStiffness()
	{
		GrippableSkeletalMeshComponent_eventGripStiffness_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripStiffness),&Parms);
		return Parms.ReturnValue;
	}
	bool UGrippableSkeletalMeshComponent::IsInteractible()
	{
		GrippableSkeletalMeshComponent_eventIsInteractible_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_IsInteractible),&Parms);
		return !!Parms.ReturnValue;
	}
	void UGrippableSkeletalMeshComponent::ObjectType(uint8& ObjectType)
	{
		GrippableSkeletalMeshComponent_eventObjectType_Parms Parms;
		Parms.ObjectType=ObjectType;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ObjectType),&Parms);
		ObjectType=Parms.ObjectType;
	}
	bool UGrippableSkeletalMeshComponent::SimulateOnDrop()
	{
		GrippableSkeletalMeshComponent_eventSimulateOnDrop_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SimulateOnDrop),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType UGrippableSkeletalMeshComponent::SlotGripType()
	{
		GrippableSkeletalMeshComponent_eventSlotGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SlotGripType),&Parms);
		return Parms.ReturnValue;
	}
	EGripInterfaceTeleportBehavior UGrippableSkeletalMeshComponent::TeleportBehavior()
	{
		GrippableSkeletalMeshComponent_eventTeleportBehavior_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_TeleportBehavior),&Parms);
		return Parms.ReturnValue;
	}
	void UGrippableSkeletalMeshComponent::StaticRegisterNativesUGrippableSkeletalMeshComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "CanHaveDoubleGrip",(Native)&UGrippableSkeletalMeshComponent::execCanHaveDoubleGrip);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "ClosestPrimarySlotInRange",(Native)&UGrippableSkeletalMeshComponent::execClosestPrimarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "ClosestSecondarySlotInRange",(Native)&UGrippableSkeletalMeshComponent::execClosestSecondarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "DenyGripping",(Native)&UGrippableSkeletalMeshComponent::execDenyGripping);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "FreeGripType",(Native)&UGrippableSkeletalMeshComponent::execFreeGripType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "GetInteractionSettings",(Native)&UGrippableSkeletalMeshComponent::execGetInteractionSettings);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "GripBreakDistance",(Native)&UGrippableSkeletalMeshComponent::execGripBreakDistance);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "GripDamping",(Native)&UGrippableSkeletalMeshComponent::execGripDamping);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "GripLateUpdateSetting",(Native)&UGrippableSkeletalMeshComponent::execGripLateUpdateSetting);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "GripMovementReplicationType",(Native)&UGrippableSkeletalMeshComponent::execGripMovementReplicationType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "GripStiffness",(Native)&UGrippableSkeletalMeshComponent::execGripStiffness);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "IsInteractible",(Native)&UGrippableSkeletalMeshComponent::execIsInteractible);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "ObjectType",(Native)&UGrippableSkeletalMeshComponent::execObjectType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "SimulateOnDrop",(Native)&UGrippableSkeletalMeshComponent::execSimulateOnDrop);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "SlotGripType",(Native)&UGrippableSkeletalMeshComponent::execSlotGripType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSkeletalMeshComponent::StaticClass(), "TeleportBehavior",(Native)&UGrippableSkeletalMeshComponent::execTeleportBehavior);
	}
	IMPLEMENT_CLASS(UGrippableSkeletalMeshComponent, 2097823783);
	bool UGrippableSphereComponent::CanHaveDoubleGrip()
	{
		GrippableSphereComponent_eventCanHaveDoubleGrip_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_CanHaveDoubleGrip),&Parms);
		return !!Parms.ReturnValue;
	}
	void UGrippableSphereComponent::ClosestPrimarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableSphereComponent_eventClosestPrimarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestPrimarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	void UGrippableSphereComponent::ClosestSecondarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableSphereComponent_eventClosestSecondarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestSecondarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	bool UGrippableSphereComponent::DenyGripping()
	{
		GrippableSphereComponent_eventDenyGripping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_DenyGripping),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType UGrippableSphereComponent::FreeGripType()
	{
		GrippableSphereComponent_eventFreeGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_FreeGripType),&Parms);
		return Parms.ReturnValue;
	}
	FBPInteractionSettings UGrippableSphereComponent::GetInteractionSettings()
	{
		GrippableSphereComponent_eventGetInteractionSettings_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GetInteractionSettings),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableSphereComponent::GripBreakDistance()
	{
		GrippableSphereComponent_eventGripBreakDistance_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripBreakDistance),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableSphereComponent::GripDamping()
	{
		GrippableSphereComponent_eventGripDamping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripDamping),&Parms);
		return Parms.ReturnValue;
	}
	EGripLateUpdateSettings UGrippableSphereComponent::GripLateUpdateSetting()
	{
		GrippableSphereComponent_eventGripLateUpdateSetting_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripLateUpdateSetting),&Parms);
		return Parms.ReturnValue;
	}
	EGripMovementReplicationSettings UGrippableSphereComponent::GripMovementReplicationType()
	{
		GrippableSphereComponent_eventGripMovementReplicationType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripMovementReplicationType),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableSphereComponent::GripStiffness()
	{
		GrippableSphereComponent_eventGripStiffness_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripStiffness),&Parms);
		return Parms.ReturnValue;
	}
	bool UGrippableSphereComponent::IsInteractible()
	{
		GrippableSphereComponent_eventIsInteractible_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_IsInteractible),&Parms);
		return !!Parms.ReturnValue;
	}
	void UGrippableSphereComponent::ObjectType(uint8& ObjectType)
	{
		GrippableSphereComponent_eventObjectType_Parms Parms;
		Parms.ObjectType=ObjectType;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ObjectType),&Parms);
		ObjectType=Parms.ObjectType;
	}
	bool UGrippableSphereComponent::SimulateOnDrop()
	{
		GrippableSphereComponent_eventSimulateOnDrop_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SimulateOnDrop),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType UGrippableSphereComponent::SlotGripType()
	{
		GrippableSphereComponent_eventSlotGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SlotGripType),&Parms);
		return Parms.ReturnValue;
	}
	EGripInterfaceTeleportBehavior UGrippableSphereComponent::TeleportBehavior()
	{
		GrippableSphereComponent_eventTeleportBehavior_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_TeleportBehavior),&Parms);
		return Parms.ReturnValue;
	}
	void UGrippableSphereComponent::StaticRegisterNativesUGrippableSphereComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "CanHaveDoubleGrip",(Native)&UGrippableSphereComponent::execCanHaveDoubleGrip);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "ClosestPrimarySlotInRange",(Native)&UGrippableSphereComponent::execClosestPrimarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "ClosestSecondarySlotInRange",(Native)&UGrippableSphereComponent::execClosestSecondarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "DenyGripping",(Native)&UGrippableSphereComponent::execDenyGripping);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "FreeGripType",(Native)&UGrippableSphereComponent::execFreeGripType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "GetInteractionSettings",(Native)&UGrippableSphereComponent::execGetInteractionSettings);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "GripBreakDistance",(Native)&UGrippableSphereComponent::execGripBreakDistance);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "GripDamping",(Native)&UGrippableSphereComponent::execGripDamping);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "GripLateUpdateSetting",(Native)&UGrippableSphereComponent::execGripLateUpdateSetting);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "GripMovementReplicationType",(Native)&UGrippableSphereComponent::execGripMovementReplicationType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "GripStiffness",(Native)&UGrippableSphereComponent::execGripStiffness);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "IsInteractible",(Native)&UGrippableSphereComponent::execIsInteractible);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "ObjectType",(Native)&UGrippableSphereComponent::execObjectType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "SimulateOnDrop",(Native)&UGrippableSphereComponent::execSimulateOnDrop);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "SlotGripType",(Native)&UGrippableSphereComponent::execSlotGripType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableSphereComponent::StaticClass(), "TeleportBehavior",(Native)&UGrippableSphereComponent::execTeleportBehavior);
	}
	IMPLEMENT_CLASS(UGrippableSphereComponent, 2257258728);
	bool AGrippableStaticMeshActor::CanHaveDoubleGrip()
	{
		GrippableStaticMeshActor_eventCanHaveDoubleGrip_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_CanHaveDoubleGrip),&Parms);
		return !!Parms.ReturnValue;
	}
	void AGrippableStaticMeshActor::ClosestPrimarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableStaticMeshActor_eventClosestPrimarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestPrimarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	void AGrippableStaticMeshActor::ClosestSecondarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableStaticMeshActor_eventClosestSecondarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestSecondarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	bool AGrippableStaticMeshActor::DenyGripping()
	{
		GrippableStaticMeshActor_eventDenyGripping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_DenyGripping),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType AGrippableStaticMeshActor::FreeGripType()
	{
		GrippableStaticMeshActor_eventFreeGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_FreeGripType),&Parms);
		return Parms.ReturnValue;
	}
	FBPInteractionSettings AGrippableStaticMeshActor::GetInteractionSettings()
	{
		GrippableStaticMeshActor_eventGetInteractionSettings_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GetInteractionSettings),&Parms);
		return Parms.ReturnValue;
	}
	float AGrippableStaticMeshActor::GripBreakDistance()
	{
		GrippableStaticMeshActor_eventGripBreakDistance_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripBreakDistance),&Parms);
		return Parms.ReturnValue;
	}
	float AGrippableStaticMeshActor::GripDamping()
	{
		GrippableStaticMeshActor_eventGripDamping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripDamping),&Parms);
		return Parms.ReturnValue;
	}
	EGripLateUpdateSettings AGrippableStaticMeshActor::GripLateUpdateSetting()
	{
		GrippableStaticMeshActor_eventGripLateUpdateSetting_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripLateUpdateSetting),&Parms);
		return Parms.ReturnValue;
	}
	EGripMovementReplicationSettings AGrippableStaticMeshActor::GripMovementReplicationType()
	{
		GrippableStaticMeshActor_eventGripMovementReplicationType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripMovementReplicationType),&Parms);
		return Parms.ReturnValue;
	}
	float AGrippableStaticMeshActor::GripStiffness()
	{
		GrippableStaticMeshActor_eventGripStiffness_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripStiffness),&Parms);
		return Parms.ReturnValue;
	}
	bool AGrippableStaticMeshActor::IsInteractible()
	{
		GrippableStaticMeshActor_eventIsInteractible_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_IsInteractible),&Parms);
		return !!Parms.ReturnValue;
	}
	void AGrippableStaticMeshActor::ObjectType(uint8& ObjectType)
	{
		GrippableStaticMeshActor_eventObjectType_Parms Parms;
		Parms.ObjectType=ObjectType;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ObjectType),&Parms);
		ObjectType=Parms.ObjectType;
	}
	bool AGrippableStaticMeshActor::SimulateOnDrop()
	{
		GrippableStaticMeshActor_eventSimulateOnDrop_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SimulateOnDrop),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType AGrippableStaticMeshActor::SlotGripType()
	{
		GrippableStaticMeshActor_eventSlotGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SlotGripType),&Parms);
		return Parms.ReturnValue;
	}
	EGripInterfaceTeleportBehavior AGrippableStaticMeshActor::TeleportBehavior()
	{
		GrippableStaticMeshActor_eventTeleportBehavior_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_TeleportBehavior),&Parms);
		return Parms.ReturnValue;
	}
	void AGrippableStaticMeshActor::StaticRegisterNativesAGrippableStaticMeshActor()
	{
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "CanHaveDoubleGrip",(Native)&AGrippableStaticMeshActor::execCanHaveDoubleGrip);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "ClosestPrimarySlotInRange",(Native)&AGrippableStaticMeshActor::execClosestPrimarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "ClosestSecondarySlotInRange",(Native)&AGrippableStaticMeshActor::execClosestSecondarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "DenyGripping",(Native)&AGrippableStaticMeshActor::execDenyGripping);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "FreeGripType",(Native)&AGrippableStaticMeshActor::execFreeGripType);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "GetInteractionSettings",(Native)&AGrippableStaticMeshActor::execGetInteractionSettings);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "GripBreakDistance",(Native)&AGrippableStaticMeshActor::execGripBreakDistance);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "GripDamping",(Native)&AGrippableStaticMeshActor::execGripDamping);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "GripLateUpdateSetting",(Native)&AGrippableStaticMeshActor::execGripLateUpdateSetting);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "GripMovementReplicationType",(Native)&AGrippableStaticMeshActor::execGripMovementReplicationType);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "GripStiffness",(Native)&AGrippableStaticMeshActor::execGripStiffness);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "IsInteractible",(Native)&AGrippableStaticMeshActor::execIsInteractible);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "ObjectType",(Native)&AGrippableStaticMeshActor::execObjectType);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "SimulateOnDrop",(Native)&AGrippableStaticMeshActor::execSimulateOnDrop);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "SlotGripType",(Native)&AGrippableStaticMeshActor::execSlotGripType);
		FNativeFunctionRegistrar::RegisterFunction(AGrippableStaticMeshActor::StaticClass(), "TeleportBehavior",(Native)&AGrippableStaticMeshActor::execTeleportBehavior);
	}
	IMPLEMENT_CLASS(AGrippableStaticMeshActor, 97717994);
	bool UGrippableStaticMeshComponent::CanHaveDoubleGrip()
	{
		GrippableStaticMeshComponent_eventCanHaveDoubleGrip_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_CanHaveDoubleGrip),&Parms);
		return !!Parms.ReturnValue;
	}
	void UGrippableStaticMeshComponent::ClosestPrimarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableStaticMeshComponent_eventClosestPrimarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestPrimarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	void UGrippableStaticMeshComponent::ClosestSecondarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform)
	{
		GrippableStaticMeshComponent_eventClosestSecondarySlotInRange_Parms Parms;
		Parms.WorldLocation=WorldLocation;
		Parms.bHadSlotInRange=bHadSlotInRange ? true : false;
		Parms.SlotWorldTransform=SlotWorldTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ClosestSecondarySlotInRange),&Parms);
		bHadSlotInRange=Parms.bHadSlotInRange;
		SlotWorldTransform=Parms.SlotWorldTransform;
	}
	bool UGrippableStaticMeshComponent::DenyGripping()
	{
		GrippableStaticMeshComponent_eventDenyGripping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_DenyGripping),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType UGrippableStaticMeshComponent::FreeGripType()
	{
		GrippableStaticMeshComponent_eventFreeGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_FreeGripType),&Parms);
		return Parms.ReturnValue;
	}
	FBPInteractionSettings UGrippableStaticMeshComponent::GetInteractionSettings()
	{
		GrippableStaticMeshComponent_eventGetInteractionSettings_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GetInteractionSettings),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableStaticMeshComponent::GripBreakDistance()
	{
		GrippableStaticMeshComponent_eventGripBreakDistance_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripBreakDistance),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableStaticMeshComponent::GripDamping()
	{
		GrippableStaticMeshComponent_eventGripDamping_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripDamping),&Parms);
		return Parms.ReturnValue;
	}
	EGripLateUpdateSettings UGrippableStaticMeshComponent::GripLateUpdateSetting()
	{
		GrippableStaticMeshComponent_eventGripLateUpdateSetting_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripLateUpdateSetting),&Parms);
		return Parms.ReturnValue;
	}
	EGripMovementReplicationSettings UGrippableStaticMeshComponent::GripMovementReplicationType()
	{
		GrippableStaticMeshComponent_eventGripMovementReplicationType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripMovementReplicationType),&Parms);
		return Parms.ReturnValue;
	}
	float UGrippableStaticMeshComponent::GripStiffness()
	{
		GrippableStaticMeshComponent_eventGripStiffness_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_GripStiffness),&Parms);
		return Parms.ReturnValue;
	}
	bool UGrippableStaticMeshComponent::IsInteractible()
	{
		GrippableStaticMeshComponent_eventIsInteractible_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_IsInteractible),&Parms);
		return !!Parms.ReturnValue;
	}
	void UGrippableStaticMeshComponent::ObjectType(uint8& ObjectType)
	{
		GrippableStaticMeshComponent_eventObjectType_Parms Parms;
		Parms.ObjectType=ObjectType;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ObjectType),&Parms);
		ObjectType=Parms.ObjectType;
	}
	bool UGrippableStaticMeshComponent::SimulateOnDrop()
	{
		GrippableStaticMeshComponent_eventSimulateOnDrop_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SimulateOnDrop),&Parms);
		return !!Parms.ReturnValue;
	}
	EGripCollisionType UGrippableStaticMeshComponent::SlotGripType()
	{
		GrippableStaticMeshComponent_eventSlotGripType_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_SlotGripType),&Parms);
		return Parms.ReturnValue;
	}
	EGripInterfaceTeleportBehavior UGrippableStaticMeshComponent::TeleportBehavior()
	{
		GrippableStaticMeshComponent_eventTeleportBehavior_Parms Parms;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_TeleportBehavior),&Parms);
		return Parms.ReturnValue;
	}
	void UGrippableStaticMeshComponent::StaticRegisterNativesUGrippableStaticMeshComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "CanHaveDoubleGrip",(Native)&UGrippableStaticMeshComponent::execCanHaveDoubleGrip);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "ClosestPrimarySlotInRange",(Native)&UGrippableStaticMeshComponent::execClosestPrimarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "ClosestSecondarySlotInRange",(Native)&UGrippableStaticMeshComponent::execClosestSecondarySlotInRange);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "DenyGripping",(Native)&UGrippableStaticMeshComponent::execDenyGripping);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "FreeGripType",(Native)&UGrippableStaticMeshComponent::execFreeGripType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "GetInteractionSettings",(Native)&UGrippableStaticMeshComponent::execGetInteractionSettings);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "GripBreakDistance",(Native)&UGrippableStaticMeshComponent::execGripBreakDistance);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "GripDamping",(Native)&UGrippableStaticMeshComponent::execGripDamping);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "GripLateUpdateSetting",(Native)&UGrippableStaticMeshComponent::execGripLateUpdateSetting);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "GripMovementReplicationType",(Native)&UGrippableStaticMeshComponent::execGripMovementReplicationType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "GripStiffness",(Native)&UGrippableStaticMeshComponent::execGripStiffness);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "IsInteractible",(Native)&UGrippableStaticMeshComponent::execIsInteractible);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "ObjectType",(Native)&UGrippableStaticMeshComponent::execObjectType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "SimulateOnDrop",(Native)&UGrippableStaticMeshComponent::execSimulateOnDrop);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "SlotGripType",(Native)&UGrippableStaticMeshComponent::execSlotGripType);
		FNativeFunctionRegistrar::RegisterFunction(UGrippableStaticMeshComponent::StaticClass(), "TeleportBehavior",(Native)&UGrippableStaticMeshComponent::execTeleportBehavior);
	}
	IMPLEMENT_CLASS(UGrippableStaticMeshComponent, 741842782);
	void UParentRelativeAttachmentComponent::StaticRegisterNativesUParentRelativeAttachmentComponent()
	{
	}
	IMPLEMENT_CLASS(UParentRelativeAttachmentComponent, 3309195089);
	void UReplicatedVRCameraComponent::Server_SendTransform(FBPVRComponentPosRep NewTransform)
	{
		ReplicatedVRCameraComponent_eventServer_SendTransform_Parms Parms;
		Parms.NewTransform=NewTransform;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_Server_SendTransform),&Parms);
	}
	void UReplicatedVRCameraComponent::StaticRegisterNativesUReplicatedVRCameraComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UReplicatedVRCameraComponent::StaticClass(), "GetCameraView",(Native)&UReplicatedVRCameraComponent::execGetCameraView);
		FNativeFunctionRegistrar::RegisterFunction(UReplicatedVRCameraComponent::StaticClass(), "OnRep_ReplicatedTransform",(Native)&UReplicatedVRCameraComponent::execOnRep_ReplicatedTransform);
		FNativeFunctionRegistrar::RegisterFunction(UReplicatedVRCameraComponent::StaticClass(), "Server_SendTransform",(Native)&UReplicatedVRCameraComponent::execServer_SendTransform);
	}
	IMPLEMENT_CLASS(UReplicatedVRCameraComponent, 1835865537);
static class UEnum* EVRControllerProperty_String_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EVRControllerProperty_String();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EVRControllerProperty_String, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EVRControllerProperty_String"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EVRControllerProperty_String(EVRControllerProperty_String_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EVRControllerProperty_String"), false, nullptr, nullptr);
static class UEnum* EVRDeviceProperty_Float_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Float();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Float, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EVRDeviceProperty_Float"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EVRDeviceProperty_Float(EVRDeviceProperty_Float_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EVRDeviceProperty_Float"), false, nullptr, nullptr);
static class UEnum* EVRDeviceProperty_Bool_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Bool();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Bool, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EVRDeviceProperty_Bool"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EVRDeviceProperty_Bool(EVRDeviceProperty_Bool_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EVRDeviceProperty_Bool"), false, nullptr, nullptr);
static class UEnum* EVRDeviceProperty_String_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_String();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_String, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EVRDeviceProperty_String"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EVRDeviceProperty_String(EVRDeviceProperty_String_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EVRDeviceProperty_String"), false, nullptr, nullptr);
static class UEnum* EBPWorldType_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPWorldType();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EBPWorldType, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EBPWorldType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EBPWorldType(EBPWorldType_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EBPWorldType"), false, nullptr, nullptr);
static class UEnum* EAsyncBlueprintResultSwitch_StaticEnum()
{
	extern VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EAsyncBlueprintResultSwitch();
		Singleton = GetStaticEnum(Z_Construct_UEnum_VRExpansionPlugin_EAsyncBlueprintResultSwitch, Z_Construct_UPackage__Script_VRExpansionPlugin(), TEXT("EAsyncBlueprintResultSwitch"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAsyncBlueprintResultSwitch(EAsyncBlueprintResultSwitch_StaticEnum, TEXT("/Script/VRExpansionPlugin"), TEXT("EAsyncBlueprintResultSwitch"), false, nullptr, nullptr);
	void UVRExpansionFunctionLibrary::StaticRegisterNativesUVRExpansionFunctionLibrary()
	{
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "CloseVRHandles",(Native)&UVRExpansionFunctionLibrary::execCloseVRHandles);
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "GetGripSlotInRangeByTypeName",(Native)&UVRExpansionFunctionLibrary::execGetGripSlotInRangeByTypeName);
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "GetGripSlotInRangeByTypeName_Component",(Native)&UVRExpansionFunctionLibrary::execGetGripSlotInRangeByTypeName_Component);
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "GetHMDPureYaw",(Native)&UVRExpansionFunctionLibrary::execGetHMDPureYaw);
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "GetHMDType",(Native)&UVRExpansionFunctionLibrary::execGetHMDType);
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "GetIsActorMovable",(Native)&UVRExpansionFunctionLibrary::execGetIsActorMovable);
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "GetIsHMDConnected",(Native)&UVRExpansionFunctionLibrary::execGetIsHMDConnected);
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "GetVRControllerPropertyString",(Native)&UVRExpansionFunctionLibrary::execGetVRControllerPropertyString);
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "GetVRDeviceModelAndTexture",(Native)&UVRExpansionFunctionLibrary::execGetVRDeviceModelAndTexture);
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "GetVRDevicePropertyBool",(Native)&UVRExpansionFunctionLibrary::execGetVRDevicePropertyBool);
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "GetVRDevicePropertyFloat",(Native)&UVRExpansionFunctionLibrary::execGetVRDevicePropertyFloat);
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "GetVRDevicePropertyString",(Native)&UVRExpansionFunctionLibrary::execGetVRDevicePropertyString);
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "IsInVREditorPreviewOrGame",(Native)&UVRExpansionFunctionLibrary::execIsInVREditorPreviewOrGame);
		FNativeFunctionRegistrar::RegisterFunction(UVRExpansionFunctionLibrary::StaticClass(), "OpenVRHandles",(Native)&UVRExpansionFunctionLibrary::execOpenVRHandles);
	}
	IMPLEMENT_CLASS(UVRExpansionFunctionLibrary, 2969422318);
	void UVRRootComponent::StaticRegisterNativesUVRRootComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UVRRootComponent::StaticClass(), "GetVRForwardVector",(Native)&UVRRootComponent::execGetVRForwardVector);
		FNativeFunctionRegistrar::RegisterFunction(UVRRootComponent::StaticClass(), "GetVRLocation",(Native)&UVRRootComponent::execGetVRLocation);
		FNativeFunctionRegistrar::RegisterFunction(UVRRootComponent::StaticClass(), "GetVRRightVector",(Native)&UVRRootComponent::execGetVRRightVector);
		FNativeFunctionRegistrar::RegisterFunction(UVRRootComponent::StaticClass(), "GetVRRotation",(Native)&UVRRootComponent::execGetVRRotation);
		FNativeFunctionRegistrar::RegisterFunction(UVRRootComponent::StaticClass(), "GetVRUpVector",(Native)&UVRRootComponent::execGetVRUpVector);
	}
	IMPLEMENT_CLASS(UVRRootComponent, 1145947970);
	void UVRCharacterMovementComponent::ServerMoveVR(float TimeStamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, FVector_NetQuantize100 CapsuleLoc, FVector_NetQuantize100 rRequestedVelocity, FVector_NetQuantize100 LFDiff, uint8 CapsuleYaw, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8 ClientMovementMode)
	{
		VRCharacterMovementComponent_eventServerMoveVR_Parms Parms;
		Parms.TimeStamp=TimeStamp;
		Parms.InAccel=InAccel;
		Parms.ClientLoc=ClientLoc;
		Parms.CapsuleLoc=CapsuleLoc;
		Parms.rRequestedVelocity=rRequestedVelocity;
		Parms.LFDiff=LFDiff;
		Parms.CapsuleYaw=CapsuleYaw;
		Parms.CompressedMoveFlags=CompressedMoveFlags;
		Parms.ClientRoll=ClientRoll;
		Parms.View=View;
		Parms.ClientMovementBase=ClientMovementBase;
		Parms.ClientBaseBoneName=ClientBaseBoneName;
		Parms.ClientMovementMode=ClientMovementMode;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ServerMoveVR),&Parms);
	}
	void UVRCharacterMovementComponent::ServerMoveVRDual(float TimeStamp0, FVector_NetQuantize10 InAccel0, uint8 PendingFlags, uint32 View0, FVector_NetQuantize100 OldCapsuleLoc, FVector_NetQuantize100 rOldRequestedVelocity, FVector_NetQuantize100 OldLFDiff, uint8 OldCapsuleYaw, float TimeStamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, FVector_NetQuantize100 CapsuleLoc, FVector_NetQuantize100 rRequestedVelocity, FVector_NetQuantize100 LFDiff, uint8 CapsuleYaw, uint8 NewFlags, uint8 ClientRoll, uint32 View, UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8 ClientMovementMode)
	{
		VRCharacterMovementComponent_eventServerMoveVRDual_Parms Parms;
		Parms.TimeStamp0=TimeStamp0;
		Parms.InAccel0=InAccel0;
		Parms.PendingFlags=PendingFlags;
		Parms.View0=View0;
		Parms.OldCapsuleLoc=OldCapsuleLoc;
		Parms.rOldRequestedVelocity=rOldRequestedVelocity;
		Parms.OldLFDiff=OldLFDiff;
		Parms.OldCapsuleYaw=OldCapsuleYaw;
		Parms.TimeStamp=TimeStamp;
		Parms.InAccel=InAccel;
		Parms.ClientLoc=ClientLoc;
		Parms.CapsuleLoc=CapsuleLoc;
		Parms.rRequestedVelocity=rRequestedVelocity;
		Parms.LFDiff=LFDiff;
		Parms.CapsuleYaw=CapsuleYaw;
		Parms.NewFlags=NewFlags;
		Parms.ClientRoll=ClientRoll;
		Parms.View=View;
		Parms.ClientMovementBase=ClientMovementBase;
		Parms.ClientBaseBoneName=ClientBaseBoneName;
		Parms.ClientMovementMode=ClientMovementMode;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ServerMoveVRDual),&Parms);
	}
	void UVRCharacterMovementComponent::ServerMoveVRDualHybridRootMotion(float TimeStamp0, FVector_NetQuantize10 InAccel0, uint8 PendingFlags, uint32 View0, FVector_NetQuantize100 OldCapsuleLoc, FVector_NetQuantize100 rOldRequestedVelocity, FVector_NetQuantize100 OldLFDiff, uint8 OldCapsuleYaw, float TimeStamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, FVector_NetQuantize100 CapsuleLoc, FVector_NetQuantize100 rRequestedVelocity, FVector_NetQuantize100 LFDiff, uint8 CapsuleYaw, uint8 NewFlags, uint8 ClientRoll, uint32 View, UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8 ClientMovementMode)
	{
		VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms Parms;
		Parms.TimeStamp0=TimeStamp0;
		Parms.InAccel0=InAccel0;
		Parms.PendingFlags=PendingFlags;
		Parms.View0=View0;
		Parms.OldCapsuleLoc=OldCapsuleLoc;
		Parms.rOldRequestedVelocity=rOldRequestedVelocity;
		Parms.OldLFDiff=OldLFDiff;
		Parms.OldCapsuleYaw=OldCapsuleYaw;
		Parms.TimeStamp=TimeStamp;
		Parms.InAccel=InAccel;
		Parms.ClientLoc=ClientLoc;
		Parms.CapsuleLoc=CapsuleLoc;
		Parms.rRequestedVelocity=rRequestedVelocity;
		Parms.LFDiff=LFDiff;
		Parms.CapsuleYaw=CapsuleYaw;
		Parms.NewFlags=NewFlags;
		Parms.ClientRoll=ClientRoll;
		Parms.View=View;
		Parms.ClientMovementBase=ClientMovementBase;
		Parms.ClientBaseBoneName=ClientBaseBoneName;
		Parms.ClientMovementMode=ClientMovementMode;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ServerMoveVRDualHybridRootMotion),&Parms);
	}
	void UVRCharacterMovementComponent::StaticRegisterNativesUVRCharacterMovementComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UVRCharacterMovementComponent::StaticClass(), "ServerMoveVR",(Native)&UVRCharacterMovementComponent::execServerMoveVR);
		FNativeFunctionRegistrar::RegisterFunction(UVRCharacterMovementComponent::StaticClass(), "ServerMoveVRDual",(Native)&UVRCharacterMovementComponent::execServerMoveVRDual);
		FNativeFunctionRegistrar::RegisterFunction(UVRCharacterMovementComponent::StaticClass(), "ServerMoveVRDualHybridRootMotion",(Native)&UVRCharacterMovementComponent::execServerMoveVRDualHybridRootMotion);
	}
	IMPLEMENT_CLASS(UVRCharacterMovementComponent, 1279423524);
	void AVRCharacter::NotifyOfTeleport()
	{
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_NotifyOfTeleport),NULL);
	}
	void AVRCharacter::ReceiveNavigationMoveCompleted(EPathFollowingResult::Type PathingResult)
	{
		VRCharacter_eventReceiveNavigationMoveCompleted_Parms Parms;
		Parms.PathingResult=PathingResult;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ReceiveNavigationMoveCompleted),&Parms);
	}
	void AVRCharacter::StaticRegisterNativesAVRCharacter()
	{
		FNativeFunctionRegistrar::RegisterFunction(AVRCharacter::StaticClass(), "ExtendedSimpleMoveToLocation",(Native)&AVRCharacter::execExtendedSimpleMoveToLocation);
		FNativeFunctionRegistrar::RegisterFunction(AVRCharacter::StaticClass(), "GetMoveStatus",(Native)&AVRCharacter::execGetMoveStatus);
		FNativeFunctionRegistrar::RegisterFunction(AVRCharacter::StaticClass(), "GetTeleportLocation",(Native)&AVRCharacter::execGetTeleportLocation);
		FNativeFunctionRegistrar::RegisterFunction(AVRCharacter::StaticClass(), "HasPartialPath",(Native)&AVRCharacter::execHasPartialPath);
		FNativeFunctionRegistrar::RegisterFunction(AVRCharacter::StaticClass(), "NotifyOfTeleport",(Native)&AVRCharacter::execNotifyOfTeleport);
		FNativeFunctionRegistrar::RegisterFunction(AVRCharacter::StaticClass(), "StopNavigationMovement",(Native)&AVRCharacter::execStopNavigationMovement);
	}
	IMPLEMENT_CLASS(AVRCharacter, 3095960348);
	void UVRPathFollowingComponent::StaticRegisterNativesUVRPathFollowingComponent()
	{
	}
	IMPLEMENT_CLASS(UVRPathFollowingComponent, 2612689256);
	void AVRPlayerController::StaticRegisterNativesAVRPlayerController()
	{
	}
	IMPLEMENT_CLASS(AVRPlayerController, 2238463700);
	void UVRSimpleCharacterMovementComponent::ServerMoveVR(float TimeStamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, FVector_NetQuantize100 rRequestedVelocity, FVector_NetQuantize100 LFDiff, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8 ClientMovementMode)
	{
		VRSimpleCharacterMovementComponent_eventServerMoveVR_Parms Parms;
		Parms.TimeStamp=TimeStamp;
		Parms.InAccel=InAccel;
		Parms.ClientLoc=ClientLoc;
		Parms.rRequestedVelocity=rRequestedVelocity;
		Parms.LFDiff=LFDiff;
		Parms.CompressedMoveFlags=CompressedMoveFlags;
		Parms.ClientRoll=ClientRoll;
		Parms.View=View;
		Parms.ClientMovementBase=ClientMovementBase;
		Parms.ClientBaseBoneName=ClientBaseBoneName;
		Parms.ClientMovementMode=ClientMovementMode;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ServerMoveVR),&Parms);
	}
	void UVRSimpleCharacterMovementComponent::ServerMoveVRDual(float TimeStamp0, FVector_NetQuantize10 InAccel0, uint8 PendingFlags, uint32 View0, FVector_NetQuantize100 rOldRequestedVelocity, FVector_NetQuantize100 OldLFDiff, float TimeStamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, FVector_NetQuantize100 rRequestedVelocity, FVector_NetQuantize100 LFDiff, uint8 NewFlags, uint8 ClientRoll, uint32 View, UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8 ClientMovementMode)
	{
		VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms Parms;
		Parms.TimeStamp0=TimeStamp0;
		Parms.InAccel0=InAccel0;
		Parms.PendingFlags=PendingFlags;
		Parms.View0=View0;
		Parms.rOldRequestedVelocity=rOldRequestedVelocity;
		Parms.OldLFDiff=OldLFDiff;
		Parms.TimeStamp=TimeStamp;
		Parms.InAccel=InAccel;
		Parms.ClientLoc=ClientLoc;
		Parms.rRequestedVelocity=rRequestedVelocity;
		Parms.LFDiff=LFDiff;
		Parms.NewFlags=NewFlags;
		Parms.ClientRoll=ClientRoll;
		Parms.View=View;
		Parms.ClientMovementBase=ClientMovementBase;
		Parms.ClientBaseBoneName=ClientBaseBoneName;
		Parms.ClientMovementMode=ClientMovementMode;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ServerMoveVRDual),&Parms);
	}
	void UVRSimpleCharacterMovementComponent::ServerMoveVRDualHybridRootMotion(float TimeStamp0, FVector_NetQuantize10 InAccel0, uint8 PendingFlags, uint32 View0, FVector_NetQuantize100 rOldRequestedVelocity, FVector_NetQuantize100 OldLFDiff, float TimeStamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, FVector_NetQuantize100 rRequestedVelocity, FVector_NetQuantize100 LFDiff, uint8 NewFlags, uint8 ClientRoll, uint32 View, UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8 ClientMovementMode)
	{
		VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms Parms;
		Parms.TimeStamp0=TimeStamp0;
		Parms.InAccel0=InAccel0;
		Parms.PendingFlags=PendingFlags;
		Parms.View0=View0;
		Parms.rOldRequestedVelocity=rOldRequestedVelocity;
		Parms.OldLFDiff=OldLFDiff;
		Parms.TimeStamp=TimeStamp;
		Parms.InAccel=InAccel;
		Parms.ClientLoc=ClientLoc;
		Parms.rRequestedVelocity=rRequestedVelocity;
		Parms.LFDiff=LFDiff;
		Parms.NewFlags=NewFlags;
		Parms.ClientRoll=ClientRoll;
		Parms.View=View;
		Parms.ClientMovementBase=ClientMovementBase;
		Parms.ClientBaseBoneName=ClientBaseBoneName;
		Parms.ClientMovementMode=ClientMovementMode;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ServerMoveVRDualHybridRootMotion),&Parms);
	}
	void UVRSimpleCharacterMovementComponent::StaticRegisterNativesUVRSimpleCharacterMovementComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UVRSimpleCharacterMovementComponent::StaticClass(), "ServerMoveVR",(Native)&UVRSimpleCharacterMovementComponent::execServerMoveVR);
		FNativeFunctionRegistrar::RegisterFunction(UVRSimpleCharacterMovementComponent::StaticClass(), "ServerMoveVRDual",(Native)&UVRSimpleCharacterMovementComponent::execServerMoveVRDual);
		FNativeFunctionRegistrar::RegisterFunction(UVRSimpleCharacterMovementComponent::StaticClass(), "ServerMoveVRDualHybridRootMotion",(Native)&UVRSimpleCharacterMovementComponent::execServerMoveVRDualHybridRootMotion);
	}
	IMPLEMENT_CLASS(UVRSimpleCharacterMovementComponent, 38624762);
	void AVRSimpleCharacter::NotifyOfTeleport()
	{
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_NotifyOfTeleport),NULL);
	}
	void AVRSimpleCharacter::ReceiveNavigationMoveCompleted(EPathFollowingResult::Type PathingResult)
	{
		VRSimpleCharacter_eventReceiveNavigationMoveCompleted_Parms Parms;
		Parms.PathingResult=PathingResult;
		ProcessEvent(FindFunctionChecked(VREXPANSIONPLUGIN_ReceiveNavigationMoveCompleted),&Parms);
	}
	void AVRSimpleCharacter::StaticRegisterNativesAVRSimpleCharacter()
	{
		FNativeFunctionRegistrar::RegisterFunction(AVRSimpleCharacter::StaticClass(), "ExtendedSimpleMoveToLocation",(Native)&AVRSimpleCharacter::execExtendedSimpleMoveToLocation);
		FNativeFunctionRegistrar::RegisterFunction(AVRSimpleCharacter::StaticClass(), "GetMoveStatus",(Native)&AVRSimpleCharacter::execGetMoveStatus);
		FNativeFunctionRegistrar::RegisterFunction(AVRSimpleCharacter::StaticClass(), "GetTeleportLocation",(Native)&AVRSimpleCharacter::execGetTeleportLocation);
		FNativeFunctionRegistrar::RegisterFunction(AVRSimpleCharacter::StaticClass(), "GetVRForwardVector",(Native)&AVRSimpleCharacter::execGetVRForwardVector);
		FNativeFunctionRegistrar::RegisterFunction(AVRSimpleCharacter::StaticClass(), "GetVRLocation",(Native)&AVRSimpleCharacter::execGetVRLocation);
		FNativeFunctionRegistrar::RegisterFunction(AVRSimpleCharacter::StaticClass(), "GetVRRightVector",(Native)&AVRSimpleCharacter::execGetVRRightVector);
		FNativeFunctionRegistrar::RegisterFunction(AVRSimpleCharacter::StaticClass(), "GetVRRotation",(Native)&AVRSimpleCharacter::execGetVRRotation);
		FNativeFunctionRegistrar::RegisterFunction(AVRSimpleCharacter::StaticClass(), "GetVRUpVector",(Native)&AVRSimpleCharacter::execGetVRUpVector);
		FNativeFunctionRegistrar::RegisterFunction(AVRSimpleCharacter::StaticClass(), "HasPartialPath",(Native)&AVRSimpleCharacter::execHasPartialPath);
		FNativeFunctionRegistrar::RegisterFunction(AVRSimpleCharacter::StaticClass(), "NotifyOfTeleport",(Native)&AVRSimpleCharacter::execNotifyOfTeleport);
		FNativeFunctionRegistrar::RegisterFunction(AVRSimpleCharacter::StaticClass(), "StopNavigationMovement",(Native)&AVRSimpleCharacter::execStopNavigationMovement);
	}
	IMPLEMENT_CLASS(AVRSimpleCharacter, 1388733186);
#if USE_COMPILED_IN_NATIVES
// Cross Module References
	ENGINE_API class UClass* Z_Construct_UClass_UPrimitiveComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AActor_NoRegister();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector();
	ENGINE_API class UClass* Z_Construct_UClass_USceneComponent_NoRegister();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FTransform();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FRotator();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVector_NetQuantize100();
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPrimitiveComponent();
	INPUTCORE_API class UEnum* Z_Construct_UEnum_InputCore_EControllerHand();
	ENGINE_API class UClass* Z_Construct_UClass_UBoxComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UCapsuleComponent();
	ENGINE_API class UClass* Z_Construct_UClass_ASkeletalMeshActor();
	ENGINE_API class UClass* Z_Construct_UClass_USkeletalMeshComponent();
	ENGINE_API class UClass* Z_Construct_UClass_USphereComponent();
	ENGINE_API class UClass* Z_Construct_UClass_AStaticMeshActor();
	ENGINE_API class UClass* Z_Construct_UClass_UStaticMeshComponent();
	ENGINE_API class UClass* Z_Construct_UClass_USceneComponent();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FMinimalViewInfo();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UTexture2D_NoRegister();
	PROCEDURALMESHCOMPONENT_API class UClass* Z_Construct_UClass_UProceduralMeshComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UActorComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ECollisionChannel();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FVector_NetQuantize10();
	ENGINE_API class UClass* Z_Construct_UClass_UCharacterMovementComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UNavigationQueryFilter_NoRegister();
	AIMODULE_API class UEnum* Z_Construct_UEnum_AIModule_EPathFollowingStatus();
	AIMODULE_API class UEnum* Z_Construct_UEnum_AIModule_EPathFollowingResult();
	ENGINE_API class UClass* Z_Construct_UClass_ACharacter();
	AIMODULE_API class UClass* Z_Construct_UClass_UPathFollowingComponent();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerController();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCapsuleComponent_NoRegister();

	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripTargetType();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripLerpState();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPHMDDeviceType();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPVRResultSwitch();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPSteamVRTrackedDeviceType();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPTrackingStatus();
	VREXPANSIONPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FBPActorPhysicsHandleInformation();
	VREXPANSIONPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FBPInterfaceProperties();
	VREXPANSIONPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FBPActorGripInformation();
	VREXPANSIONPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FBPInteractionSettings();
	VREXPANSIONPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FBPVRComponentPosRep();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_CanHaveDoubleGrip();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_ClosestPrimarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_ClosestSecondarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_DenyGripping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_FreeGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_GetInteractionSettings();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_GripBreakDistance();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_GripDamping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_GripLateUpdateSetting();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_GripMovementReplicationType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_GripStiffness();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_IsInteractible();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_ObjectType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_OnChildGrip();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_OnChildGripRelease();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_OnEndUsed();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_OnGrip();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_OnGripRelease();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_OnSecondaryGrip();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_OnSecondaryGripRelease();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_OnUsed();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_SimulateOnDrop();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_SlotGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_TeleportBehavior();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRGripInterface_TickGrip();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UVRGripInterface_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UVRGripInterface();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_AddSecondaryAttachmentPoint();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_ConvertToControllerRelativeTransform();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_ConvertToGripRelativeTransform();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_CreateGripRelativeAdditionTransform_BP();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_DropActor();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_DropComponent();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_DropGrip();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_DropObject();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_DropObjectByInterface();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetGripByActor();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetGripByComponent();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetGrippedActors();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetGrippedComponents();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetIsComponentHeld();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetIsHeld();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetIsObjectHeld();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetIsSecondaryAttachment();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetPhysicsVelocities();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GripActor();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GripComponent();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GripObject();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GripObjectByInterface();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_IsTracked();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_NotifyDrop();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_OnRep_GrippedActors();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_OnRep_ReplicatedControllerTransform();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_PostTeleportMoveGrippedActors();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_RemoveSecondaryAttachmentPoint();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_Server_SendControllerTransform();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_SetGripAdditionTransform();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_SetGripLateUpdateSetting();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_SetGripRelativeTransform();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_TeleportMoveGrip();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_TeleportMoveGrippedActor();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_TeleportMoveGrippedComponent();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UGripMotionControllerComponent_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UGripMotionControllerComponent();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_CanHaveDoubleGrip();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_ClosestPrimarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_ClosestSecondarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_DenyGripping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_FreeGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_GetInteractionSettings();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_GripBreakDistance();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_GripDamping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_GripLateUpdateSetting();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_GripMovementReplicationType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_GripStiffness();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_IsInteractible();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_ObjectType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_SimulateOnDrop();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_SlotGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableBoxComponent_TeleportBehavior();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UGrippableBoxComponent_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UGrippableBoxComponent();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_CanHaveDoubleGrip();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_ClosestPrimarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_ClosestSecondarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_DenyGripping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_FreeGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_GetInteractionSettings();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_GripBreakDistance();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_GripDamping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_GripLateUpdateSetting();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_GripMovementReplicationType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_GripStiffness();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_IsInteractible();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_ObjectType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_SimulateOnDrop();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_SlotGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_TeleportBehavior();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UGrippableCapsuleComponent_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UGrippableCapsuleComponent();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_CanHaveDoubleGrip();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_ClosestPrimarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_ClosestSecondarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_DenyGripping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_FreeGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_GetInteractionSettings();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripBreakDistance();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripDamping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripLateUpdateSetting();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripMovementReplicationType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripStiffness();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_IsInteractible();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_ObjectType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_SimulateOnDrop();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_SlotGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_TeleportBehavior();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_AGrippableSkeletalMeshActor_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_AGrippableSkeletalMeshActor();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_CanHaveDoubleGrip();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_ClosestPrimarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_ClosestSecondarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_DenyGripping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_FreeGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GetInteractionSettings();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripBreakDistance();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripDamping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripLateUpdateSetting();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripMovementReplicationType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripStiffness();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_IsInteractible();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_ObjectType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_SimulateOnDrop();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_SlotGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_TeleportBehavior();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UGrippableSkeletalMeshComponent_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UGrippableSkeletalMeshComponent();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_CanHaveDoubleGrip();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_ClosestPrimarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_ClosestSecondarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_DenyGripping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_FreeGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_GetInteractionSettings();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_GripBreakDistance();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_GripDamping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_GripLateUpdateSetting();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_GripMovementReplicationType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_GripStiffness();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_IsInteractible();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_ObjectType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_SimulateOnDrop();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_SlotGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableSphereComponent_TeleportBehavior();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UGrippableSphereComponent_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UGrippableSphereComponent();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_CanHaveDoubleGrip();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_ClosestPrimarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_ClosestSecondarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_DenyGripping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_FreeGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_GetInteractionSettings();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_GripBreakDistance();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_GripDamping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_GripLateUpdateSetting();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_GripMovementReplicationType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_GripStiffness();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_IsInteractible();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_ObjectType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_SimulateOnDrop();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_SlotGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_TeleportBehavior();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_AGrippableStaticMeshActor_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_AGrippableStaticMeshActor();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_CanHaveDoubleGrip();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_ClosestPrimarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_ClosestSecondarySlotInRange();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_DenyGripping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_FreeGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_GetInteractionSettings();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_GripBreakDistance();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_GripDamping();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_GripLateUpdateSetting();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_GripMovementReplicationType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_GripStiffness();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_IsInteractible();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_ObjectType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_SimulateOnDrop();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_SlotGripType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_TeleportBehavior();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UGrippableStaticMeshComponent_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UGrippableStaticMeshComponent();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UParentRelativeAttachmentComponent_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UParentRelativeAttachmentComponent();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UReplicatedVRCameraComponent_GetCameraView();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UReplicatedVRCameraComponent_OnRep_ReplicatedTransform();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UReplicatedVRCameraComponent_Server_SendTransform();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UReplicatedVRCameraComponent_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UReplicatedVRCameraComponent();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EVRControllerProperty_String();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Float();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Bool();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_String();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPWorldType();
	VREXPANSIONPLUGIN_API class UEnum* Z_Construct_UEnum_VRExpansionPlugin_EAsyncBlueprintResultSwitch();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_CloseVRHandles();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetGripSlotInRangeByTypeName();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetGripSlotInRangeByTypeName_Component();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetHMDPureYaw();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetHMDType();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetIsActorMovable();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetIsHMDConnected();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRControllerPropertyString();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDeviceModelAndTexture();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDevicePropertyBool();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDevicePropertyFloat();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDevicePropertyString();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_IsInVREditorPreviewOrGame();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_OpenVRHandles();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UVRExpansionFunctionLibrary_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UVRExpansionFunctionLibrary();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRRootComponent_GetVRForwardVector();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRRootComponent_GetVRLocation();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRRootComponent_GetVRRightVector();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRRootComponent_GetVRRotation();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRRootComponent_GetVRUpVector();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UVRRootComponent_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UVRRootComponent();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRCharacterMovementComponent_ServerMoveVR();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRCharacterMovementComponent_ServerMoveVRDual();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRCharacterMovementComponent_ServerMoveVRDualHybridRootMotion();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UVRCharacterMovementComponent_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UVRCharacterMovementComponent();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRCharacter_ExtendedSimpleMoveToLocation();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRCharacter_GetMoveStatus();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRCharacter_GetTeleportLocation();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRCharacter_HasPartialPath();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRCharacter_NotifyOfTeleport();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRCharacter_ReceiveNavigationMoveCompleted();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRCharacter_StopNavigationMovement();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_AVRCharacter_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_AVRCharacter();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UVRPathFollowingComponent_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UVRPathFollowingComponent();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_AVRPlayerController_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_AVRPlayerController();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRSimpleCharacterMovementComponent_ServerMoveVR();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRSimpleCharacterMovementComponent_ServerMoveVRDual();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_UVRSimpleCharacterMovementComponent_ServerMoveVRDualHybridRootMotion();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UVRSimpleCharacterMovementComponent_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_UVRSimpleCharacterMovementComponent();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRSimpleCharacter_ExtendedSimpleMoveToLocation();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetMoveStatus();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetTeleportLocation();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetVRForwardVector();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetVRLocation();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetVRRightVector();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetVRRotation();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetVRUpVector();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRSimpleCharacter_HasPartialPath();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRSimpleCharacter_NotifyOfTeleport();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRSimpleCharacter_ReceiveNavigationMoveCompleted();
	VREXPANSIONPLUGIN_API class UFunction* Z_Construct_UFunction_AVRSimpleCharacter_StopNavigationMovement();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_AVRSimpleCharacter_NoRegister();
	VREXPANSIONPLUGIN_API class UClass* Z_Construct_UClass_AVRSimpleCharacter();
	VREXPANSIONPLUGIN_API class UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EGripInterfaceTeleportBehavior"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EGripInterfaceTeleportBehavior"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("TeleportAllComponents")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("OnlyTeleportRootComponent")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DropOnTeleport")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DontTeleport")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EGripInterfaceTeleportBehavior_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("EGripInterfaceTeleportBehavior");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("IsBlueprintBase"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Lerp states"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior_CRC() { return 983572140U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripTargetType()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EGripTargetType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EGripTargetType"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EGripTargetType_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EGripTargetType"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ActorGrip")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ComponentGrip")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EGripTargetType_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("EGripTargetType");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("IsBlueprintBase"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Grip Target Type"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EGripTargetType_CRC() { return 3644132978U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EGripMovementReplicationSettings"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EGripMovementReplicationSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("KeepOriginalMovement")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ForceServerSideMovement")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ForceClientSideMovement")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EGripMovementReplicationSettings_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("EGripMovementReplicationSettings");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("IsBlueprintBase"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Grip movement replication settings\nServerSideMovementOnlyWhenColliding is not InteractivePhysicsGripCompatible"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings_CRC() { return 3741551139U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EGripLateUpdateSettings"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EGripLateUpdateSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("LateUpdatesAlwaysOn")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("LateUpdatesAlwaysOff")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("NotWhenColliding")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("NotWhenDoubleGripping")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("NotWhenCollidingOrDoubleGripping")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EGripLateUpdateSettings_MAX")), 5));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("EGripLateUpdateSettings");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("IsBlueprintBase"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Grip Late Update informaiton"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings_CRC() { return 1943912992U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripLerpState()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EGripLerpState_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EGripLerpState"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EGripLerpState_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EGripLerpState"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("StartLerp")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EndLerp")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ConstantLerp")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("NotLerping")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EGripLerpState_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("EGripLerpState");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("IsBlueprintBase"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Lerp states"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EGripLerpState_CRC() { return 21093781U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPHMDDeviceType()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EBPHMDDeviceType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EBPHMDDeviceType"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EBPHMDDeviceType_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EBPHMDDeviceType"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DT_OculusRift")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DT_Morpheus")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DT_ES2GenericStereoMesh")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DT_SteamVR")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DT_GearVR")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DT_Unknown")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DT_MAX")), 6));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("EBPHMDDeviceType");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("IsBlueprintBase"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("This needs to be updated as the original gets changed, that or hope they make the original blueprint accessible."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EBPHMDDeviceType_CRC() { return 157800424U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EGripCollisionType"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EGripCollisionType"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("InteractiveCollisionWithPhysics")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("InteractiveCollisionWithSweep")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("InteractiveHybridCollisionWithSweep")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("SweepWithPhysics")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("PhysicsOnly")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ManipulationGrip")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("CustomGrip")), 6));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EGripCollisionType_MAX")), 7));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("EGripCollisionType");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("InteractiveCollisionWithSweep.ToolTip"), TEXT("InteractiveCollisionWithVelocity,"));
			MetaData->SetValue(ReturnEnum, TEXT("IsBlueprintBase"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Interactive Collision With Physics = Held items can be offset by geometry, uses physics for the offset, pushes physics simulating objects with weight taken into account\nInteractive Collision With Sweep = Held items can be offset by geometry, uses sweep for the offset, pushes physics simulating objects, no weight\nSweep With Physics = Only sweeps movement, will not be offset by geomtry, still pushes physics simulating objects, no weight\nPhysics Only = Does not sweep at all (does not trigger OnHitEvents), still pushes physics simulating objects, no weight\nCustom grip is to be handled by the object itself, it just sends the TickGrip event every frame but doesn't move the object."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType_CRC() { return 3317966068U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPVRResultSwitch()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EBPVRResultSwitch_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EBPVRResultSwitch"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EBPVRResultSwitch_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EBPVRResultSwitch"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPVRResultSwitch::OnSucceeded")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPVRResultSwitch::OnFailed")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPVRResultSwitch::EBPVRResultSwitch_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("EBPVRResultSwitch::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("OnFailed.ToolTip"), TEXT("On Failure"));
			MetaData->SetValue(ReturnEnum, TEXT("OnSucceeded.ToolTip"), TEXT("On Success"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("This makes a lot of the blueprint functions cleaner"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EBPVRResultSwitch_CRC() { return 1835722346U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPSteamVRTrackedDeviceType()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EBPSteamVRTrackedDeviceType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EBPSteamVRTrackedDeviceType"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EBPSteamVRTrackedDeviceType_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EBPSteamVRTrackedDeviceType"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPSteamVRTrackedDeviceType::Controller")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPSteamVRTrackedDeviceType::TrackingReference")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPSteamVRTrackedDeviceType::Other")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPSteamVRTrackedDeviceType::Invalid")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPSteamVRTrackedDeviceType::EBPSteamVRTrackedDeviceType_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
			ReturnEnum->CppType = TEXT("EBPSteamVRTrackedDeviceType");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("Controller.ToolTip"), TEXT("Represents a Steam VR Controller"));
			MetaData->SetValue(ReturnEnum, TEXT("Invalid.ToolTip"), TEXT("DeviceId is invalid"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("Other.ToolTip"), TEXT("Misc. device types, for future expansion"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Defines the class of tracked devices in SteamVR"));
			MetaData->SetValue(ReturnEnum, TEXT("TrackingReference.ToolTip"), TEXT("Represents a static tracking reference device, such as a Lighthouse or tracking camera"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EBPSteamVRTrackedDeviceType_CRC() { return 3222958842U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPTrackingStatus()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EBPTrackingStatus_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EBPTrackingStatus"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EBPTrackingStatus_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EBPTrackingStatus"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPTrackingStatus::NotTracked")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPTrackingStatus::InertialOnly")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPTrackingStatus::Tracked")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPTrackingStatus::EBPTrackingStatus_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
			ReturnEnum->CppType = TEXT("EBPTrackingStatus");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Temp until full conversion past 4.13, breaks 4.14 / 4.13 cross conversion\n ETrackingStatus"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EBPTrackingStatus_CRC() { return 2370499057U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBPActorPhysicsHandleInformation()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FBPActorPhysicsHandleInformation_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("BPActorPhysicsHandleInformation"), sizeof(FBPActorPhysicsHandleInformation), Get_Z_Construct_UScriptStruct_FBPActorPhysicsHandleInformation_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BPActorPhysicsHandleInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBPActorPhysicsHandleInformation>, EStructFlags(0x00000205));
			UProperty* NewProp_Component = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Component"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Component, FBPActorPhysicsHandleInformation), 0x001000000008001c, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_Actor = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Actor"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Actor, FBPActorPhysicsHandleInformation), 0x0010000000000014, Z_Construct_UClass_AActor_NoRegister());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("Category"), TEXT("VRExpansionLibrary"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_Component, TEXT("Category"), TEXT("BPActorPhysicsHandleInformation"));
			MetaData->SetValue(NewProp_Component, TEXT("EditInline"), TEXT("true"));
			MetaData->SetValue(NewProp_Component, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_Actor, TEXT("Category"), TEXT("BPActorPhysicsHandleInformation"));
			MetaData->SetValue(NewProp_Actor, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBPActorPhysicsHandleInformation_CRC() { return 3182591169U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBPInterfaceProperties()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FBPInterfaceProperties_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("BPInterfaceProperties"), sizeof(FBPInterfaceProperties), Get_Z_Construct_UScriptStruct_FBPInterfaceProperties_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BPInterfaceProperties"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBPInterfaceProperties>, EStructFlags(0x00000201));
			UProperty* NewProp_InteractionSettings = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InteractionSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InteractionSettings, FBPInterfaceProperties), 0x0010000000000005, Z_Construct_UScriptStruct_FBPInteractionSettings());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsInteractible, FBPInterfaceProperties, bool);
			UProperty* NewProp_bIsInteractible = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bIsInteractible"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsInteractible, FBPInterfaceProperties), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsInteractible, FBPInterfaceProperties), sizeof(bool), true);
			UProperty* NewProp_PrimarySlotRange = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("PrimarySlotRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(PrimarySlotRange, FBPInterfaceProperties), 0x0010000000000005);
			UProperty* NewProp_SecondarySlotRange = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SecondarySlotRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SecondarySlotRange, FBPInterfaceProperties), 0x0010000000000005);
			UProperty* NewProp_ConstraintBreakDistance = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ConstraintBreakDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ConstraintBreakDistance, FBPInterfaceProperties), 0x0010000000000005);
			UProperty* NewProp_ConstraintDamping = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ConstraintDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ConstraintDamping, FBPInterfaceProperties), 0x0010000000000005);
			UProperty* NewProp_ConstraintStiffness = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ConstraintStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ConstraintStiffness, FBPInterfaceProperties), 0x0010000000000005);
			UProperty* NewProp_LateUpdateSetting = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(LateUpdateSetting, FBPInterfaceProperties), 0x0010000000000005, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			UProperty* NewProp_MovementReplicationType = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MovementReplicationType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(MovementReplicationType, FBPInterfaceProperties), 0x0010000000000005, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanHaveDoubleGrip, FBPInterfaceProperties, bool);
			UProperty* NewProp_bCanHaveDoubleGrip = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bCanHaveDoubleGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanHaveDoubleGrip, FBPInterfaceProperties), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bCanHaveDoubleGrip, FBPInterfaceProperties), sizeof(bool), true);
			UProperty* NewProp_FreeDefaultGripType = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("FreeDefaultGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FreeDefaultGripType, FBPInterfaceProperties), 0x0010000000000005, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			UProperty* NewProp_SlotDefaultGripType = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SlotDefaultGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(SlotDefaultGripType, FBPInterfaceProperties), 0x0010000000000005, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			UProperty* NewProp_EnumObjectType = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("EnumObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(EnumObjectType, FBPInterfaceProperties), 0x0010000000000005);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSimulateOnDrop, FBPInterfaceProperties, bool);
			UProperty* NewProp_bSimulateOnDrop = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bSimulateOnDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSimulateOnDrop, FBPInterfaceProperties), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bSimulateOnDrop, FBPInterfaceProperties), sizeof(bool), true);
			UProperty* NewProp_OnTeleportBehavior = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("OnTeleportBehavior"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(OnTeleportBehavior, FBPInterfaceProperties), 0x0010000000000005, Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDenyGripping, FBPInterfaceProperties, bool);
			UProperty* NewProp_bDenyGripping = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bDenyGripping"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDenyGripping, FBPInterfaceProperties), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bDenyGripping, FBPInterfaceProperties), sizeof(bool), true);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("Category"), TEXT("VRExpansionLibrary"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_InteractionSettings, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_InteractionSettings, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bIsInteractible, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_bIsInteractible, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_PrimarySlotRange, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_PrimarySlotRange, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_SecondarySlotRange, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_SecondarySlotRange, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_ConstraintBreakDistance, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_ConstraintBreakDistance, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_ConstraintDamping, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_ConstraintDamping, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_ConstraintStiffness, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_ConstraintStiffness, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_LateUpdateSetting, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_LateUpdateSetting, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_MovementReplicationType, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_MovementReplicationType, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_MovementReplicationType, TEXT("ToolTip"), TEXT("UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"VRGripInterface\")\n       TEnumAsByte<EGripTargetType> GripTarget;"));
			MetaData->SetValue(NewProp_bCanHaveDoubleGrip, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_bCanHaveDoubleGrip, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_FreeDefaultGripType, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_FreeDefaultGripType, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_SlotDefaultGripType, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_SlotDefaultGripType, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_EnumObjectType, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_EnumObjectType, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bSimulateOnDrop, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_bSimulateOnDrop, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_OnTeleportBehavior, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_OnTeleportBehavior, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bDenyGripping, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(NewProp_bDenyGripping, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBPInterfaceProperties_CRC() { return 2965127361U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBPActorGripInformation()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FBPActorGripInformation_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("BPActorGripInformation"), sizeof(FBPActorGripInformation), Get_Z_Construct_UScriptStruct_FBPActorGripInformation_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BPActorGripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBPActorGripInformation>, EStructFlags(0x00000205));
			UProperty* NewProp_LerpToRate = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LerpToRate"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LerpToRate, FBPActorGripInformation), 0x0010000000000000);
			UProperty* NewProp_SecondaryRelativeLocation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SecondaryRelativeLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SecondaryRelativeLocation, FBPActorGripInformation), 0x0010000000000000, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_SecondarySmoothingScaler = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SecondarySmoothingScaler"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SecondarySmoothingScaler, FBPActorGripInformation), 0x0010000000000004);
			UProperty* NewProp_SecondaryAttachment = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SecondaryAttachment"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(SecondaryAttachment, FBPActorGripInformation), 0x001000000008001c, Z_Construct_UClass_USceneComponent_NoRegister());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHasSecondaryAttachment, FBPActorGripInformation, bool);
			UProperty* NewProp_bHasSecondaryAttachment = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bHasSecondaryAttachment"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHasSecondaryAttachment, FBPActorGripInformation), 0x0010000000000014, CPP_BOOL_PROPERTY_BITMASK(bHasSecondaryAttachment, FBPActorGripInformation), sizeof(bool), true);
			UProperty* NewProp_Stiffness = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Stiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Stiffness, FBPActorGripInformation), 0x0010000000000000);
			UProperty* NewProp_Damping = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Damping"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Damping, FBPActorGripInformation), 0x0010000000000000);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOriginalReplicatesMovement, FBPActorGripInformation, bool);
			UProperty* NewProp_bOriginalReplicatesMovement = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bOriginalReplicatesMovement"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOriginalReplicatesMovement, FBPActorGripInformation), 0x0010000000000014, CPP_BOOL_PROPERTY_BITMASK(bOriginalReplicatesMovement, FBPActorGripInformation), sizeof(bool), true);
			UProperty* NewProp_GripMovementReplicationSetting = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("GripMovementReplicationSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GripMovementReplicationSetting, FBPActorGripInformation), 0x0010000000000014, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			UProperty* NewProp_RelativeTransform = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RelativeTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(RelativeTransform, FBPActorGripInformation), 0x0010000000000004, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_GripLateUpdateSetting = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("GripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GripLateUpdateSetting, FBPActorGripInformation), 0x0010000000000004, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			UProperty* NewProp_GripCollisionType = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("GripCollisionType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GripCollisionType, FBPActorGripInformation), 0x0010000000000014, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			UProperty* NewProp_Component = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Component"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Component, FBPActorGripInformation), 0x001000000008001c, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_Actor = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Actor"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Actor, FBPActorGripInformation), 0x0010000000000014, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_GripTargetType = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("GripTargetType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GripTargetType, FBPActorGripInformation), 0x0010000000000014, Z_Construct_UEnum_VRExpansionPlugin_EGripTargetType());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("Category"), TEXT("VRExpansionLibrary"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_LerpToRate, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_LerpToRate, TEXT("ToolTip"), TEXT("Lerp transitions"));
			MetaData->SetValue(NewProp_SecondaryRelativeLocation, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_SecondarySmoothingScaler, TEXT("Category"), TEXT("BPActorGripInformation"));
			MetaData->SetValue(NewProp_SecondarySmoothingScaler, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_SecondaryAttachment, TEXT("Category"), TEXT("BPActorGripInformation"));
			MetaData->SetValue(NewProp_SecondaryAttachment, TEXT("EditInline"), TEXT("true"));
			MetaData->SetValue(NewProp_SecondaryAttachment, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bHasSecondaryAttachment, TEXT("Category"), TEXT("BPActorGripInformation"));
			MetaData->SetValue(NewProp_bHasSecondaryAttachment, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bHasSecondaryAttachment, TEXT("ToolTip"), TEXT("For multi grip situations"));
			MetaData->SetValue(NewProp_Stiffness, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_Damping, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bOriginalReplicatesMovement, TEXT("Category"), TEXT("BPActorGripInformation"));
			MetaData->SetValue(NewProp_bOriginalReplicatesMovement, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_GripMovementReplicationSetting, TEXT("Category"), TEXT("BPActorGripInformation"));
			MetaData->SetValue(NewProp_GripMovementReplicationSetting, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_RelativeTransform, TEXT("Category"), TEXT("BPActorGripInformation"));
			MetaData->SetValue(NewProp_RelativeTransform, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_GripLateUpdateSetting, TEXT("Category"), TEXT("BPActorGripInformation"));
			MetaData->SetValue(NewProp_GripLateUpdateSetting, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_GripCollisionType, TEXT("Category"), TEXT("BPActorGripInformation"));
			MetaData->SetValue(NewProp_GripCollisionType, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_Component, TEXT("Category"), TEXT("BPActorGripInformation"));
			MetaData->SetValue(NewProp_Component, TEXT("EditInline"), TEXT("true"));
			MetaData->SetValue(NewProp_Component, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_Actor, TEXT("Category"), TEXT("BPActorGripInformation"));
			MetaData->SetValue(NewProp_Actor, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_GripTargetType, TEXT("Category"), TEXT("BPActorGripInformation"));
			MetaData->SetValue(NewProp_GripTargetType, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBPActorGripInformation_CRC() { return 2278292001U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBPInteractionSettings()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FBPInteractionSettings_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("BPInteractionSettings"), sizeof(FBPInteractionSettings), Get_Z_Construct_UScriptStruct_FBPInteractionSettings_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BPInteractionSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBPInteractionSettings>, EStructFlags(0x00000201));
			UProperty* NewProp_MaxAngularTranslation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MaxAngularTranslation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MaxAngularTranslation, FBPInteractionSettings), 0x0010000000000005, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_MinAngularTranslation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MinAngularTranslation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MinAngularTranslation, FBPInteractionSettings), 0x0010000000000005, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_InitialAngularTranslation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InitialAngularTranslation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InitialAngularTranslation, FBPInteractionSettings), 0x0010000000000005, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_MaxLinearTranslation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MaxLinearTranslation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MaxLinearTranslation, FBPInteractionSettings), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_MinLinearTranslation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MinLinearTranslation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MinLinearTranslation, FBPInteractionSettings), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_InitialLinearTranslation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InitialLinearTranslation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InitialLinearTranslation, FBPInteractionSettings), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIgnoreHandRotation, FBPInteractionSettings, uint8);
			UProperty* NewProp_bIgnoreHandRotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bIgnoreHandRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIgnoreHandRotation, FBPInteractionSettings), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bIgnoreHandRotation, FBPInteractionSettings), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLimitRoll, FBPInteractionSettings, uint8);
			UProperty* NewProp_bLimitRoll = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLimitRoll"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLimitRoll, FBPInteractionSettings), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bLimitRoll, FBPInteractionSettings), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLimitYaw, FBPInteractionSettings, uint8);
			UProperty* NewProp_bLimitYaw = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLimitYaw"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLimitYaw, FBPInteractionSettings), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bLimitYaw, FBPInteractionSettings), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLimitPitch, FBPInteractionSettings, uint8);
			UProperty* NewProp_bLimitPitch = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLimitPitch"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLimitPitch, FBPInteractionSettings), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bLimitPitch, FBPInteractionSettings), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLimitZ, FBPInteractionSettings, uint8);
			UProperty* NewProp_bLimitZ = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLimitZ"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLimitZ, FBPInteractionSettings), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bLimitZ, FBPInteractionSettings), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLimitY, FBPInteractionSettings, uint8);
			UProperty* NewProp_bLimitY = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLimitY"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLimitY, FBPInteractionSettings), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bLimitY, FBPInteractionSettings), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLimitX, FBPInteractionSettings, uint8);
			UProperty* NewProp_bLimitX = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLimitX"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLimitX, FBPInteractionSettings), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bLimitX, FBPInteractionSettings), sizeof(uint8), false);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bLimitsInLocalSpace, FBPInteractionSettings, uint8);
			UProperty* NewProp_bLimitsInLocalSpace = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bLimitsInLocalSpace"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bLimitsInLocalSpace, FBPInteractionSettings), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bLimitsInLocalSpace, FBPInteractionSettings), sizeof(uint8), false);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("Category"), TEXT("VRExpansionLibrary"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_MaxAngularTranslation, TEXT("Category"), TEXT("AngularSettings"));
			MetaData->SetValue(NewProp_MaxAngularTranslation, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_MinAngularTranslation, TEXT("Category"), TEXT("AngularSettings"));
			MetaData->SetValue(NewProp_MinAngularTranslation, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_InitialAngularTranslation, TEXT("Category"), TEXT("AngularSettings"));
			MetaData->SetValue(NewProp_InitialAngularTranslation, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_MaxLinearTranslation, TEXT("Category"), TEXT("LinearSettings"));
			MetaData->SetValue(NewProp_MaxLinearTranslation, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_MinLinearTranslation, TEXT("Category"), TEXT("LinearSettings"));
			MetaData->SetValue(NewProp_MinLinearTranslation, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_InitialLinearTranslation, TEXT("Category"), TEXT("LinearSettings"));
			MetaData->SetValue(NewProp_InitialLinearTranslation, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bIgnoreHandRotation, TEXT("Category"), TEXT("AngularSettings"));
			MetaData->SetValue(NewProp_bIgnoreHandRotation, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bIgnoreHandRotation, TEXT("ToolTip"), TEXT("Doesn't work totally correctly without using the ConvertToControllerRelativeTransform node in the motion controller"));
			MetaData->SetValue(NewProp_bLimitRoll, TEXT("Category"), TEXT("AngularSettings"));
			MetaData->SetValue(NewProp_bLimitRoll, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bLimitYaw, TEXT("Category"), TEXT("AngularSettings"));
			MetaData->SetValue(NewProp_bLimitYaw, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bLimitPitch, TEXT("Category"), TEXT("AngularSettings"));
			MetaData->SetValue(NewProp_bLimitPitch, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bLimitZ, TEXT("Category"), TEXT("LinearSettings"));
			MetaData->SetValue(NewProp_bLimitZ, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bLimitY, TEXT("Category"), TEXT("LinearSettings"));
			MetaData->SetValue(NewProp_bLimitY, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bLimitX, TEXT("Category"), TEXT("LinearSettings"));
			MetaData->SetValue(NewProp_bLimitX, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_bLimitsInLocalSpace, TEXT("Category"), TEXT("BPInteractionSettings"));
			MetaData->SetValue(NewProp_bLimitsInLocalSpace, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBPInteractionSettings_CRC() { return 2217952637U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBPVRComponentPosRep()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FBPVRComponentPosRep_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("BPVRComponentPosRep"), sizeof(FBPVRComponentPosRep), Get_Z_Construct_UScriptStruct_FBPVRComponentPosRep_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BPVRComponentPosRep"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FBPVRComponentPosRep>, EStructFlags(0x00000201));
			UProperty* NewProp_RollBYTE = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("RollBYTE"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(RollBYTE, FBPVRComponentPosRep), 0x0010000000000000);
			UProperty* NewProp_YawPitchINT = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("YawPitchINT"), RF_Public|RF_Transient|RF_MarkAsNative) UUInt32Property(CPP_PROPERTY_BASE(YawPitchINT, FBPVRComponentPosRep), 0x0010000000000000);
			UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Position"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Position, FBPVRComponentPosRep), 0x0010000000000000, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_RollBYTE, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_YawPitchINT, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
			MetaData->SetValue(NewProp_Position, TEXT("ModuleRelativePath"), TEXT("Public/VRBPDatatypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBPVRComponentPosRep_CRC() { return 1913323580U; }
	UFunction* Z_Construct_UFunction_UVRGripInterface_CanHaveDoubleGrip()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanHaveDoubleGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(VRGripInterface_eventCanHaveDoubleGrip_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRGripInterface_eventCanHaveDoubleGrip_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRGripInterface_eventCanHaveDoubleGrip_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRGripInterface_eventCanHaveDoubleGrip_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Can have secondary grip"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_ClosestPrimarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestPrimarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(VRGripInterface_eventClosestPrimarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, VRGripInterface_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, VRGripInterface_eventClosestPrimarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, VRGripInterface_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, VRGripInterface_eventClosestPrimarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, VRGripInterface_eventClosestPrimarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest primary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_ClosestSecondarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestSecondarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(VRGripInterface_eventClosestSecondarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, VRGripInterface_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, VRGripInterface_eventClosestSecondarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, VRGripInterface_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, VRGripInterface_eventClosestSecondarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, VRGripInterface_eventClosestSecondarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest secondary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_DenyGripping()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DenyGripping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(VRGripInterface_eventDenyGripping_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRGripInterface_eventDenyGripping_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRGripInterface_eventDenyGripping_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRGripInterface_eventDenyGripping_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set up as deny instead of allow so that default allows for gripping"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_FreeGripType()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FreeGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(VRGripInterface_eventFreeGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventFreeGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when not gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_GetInteractionSettings()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInteractionSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(VRGripInterface_eventGetInteractionSettings_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventGetInteractionSettings_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FBPInteractionSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get interactable settings"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_GripBreakDistance()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripBreakDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(VRGripInterface_eventGripBreakDistance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventGripBreakDistance_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What distance to break a grip at (only relevent with physics enabled grips"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_GripDamping()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(VRGripInterface_eventGripDamping_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventGripDamping_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip damping to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_GripLateUpdateSetting()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(VRGripInterface_eventGripLateUpdateSetting_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventGripLateUpdateSetting_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define the late update setting"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_GripMovementReplicationType()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripMovementReplicationType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(VRGripInterface_eventGripMovementReplicationType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventGripMovementReplicationType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define which movement repliation setting to use"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_GripStiffness()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(VRGripInterface_eventGripStiffness_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventGripStiffness_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip stiffness to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_IsInteractible()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsInteractible"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(VRGripInterface_eventIsInteractible_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRGripInterface_eventIsInteractible_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRGripInterface_eventIsInteractible_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRGripInterface_eventIsInteractible_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the object is an interactable"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_ObjectType()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(VRGripInterface_eventObjectType_Parms));
			UProperty* NewProp_ObjectType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ObjectType, VRGripInterface_eventObjectType_Parms), 0x0010000000000180);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Type of object, fill in with your own enum"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnChildGrip()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnChildGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08420800, 65535, sizeof(VRGripInterface_eventOnChildGrip_Parms));
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventOnChildGrip_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_GrippingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrippingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(GrippingController, VRGripInterface_eventOnChildGrip_Parms), 0x0010000000080080, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered on the interfaced object when child component is gripped"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_GrippingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnChildGripRelease()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnChildGripRelease"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08420800, 65535, sizeof(VRGripInterface_eventOnChildGripRelease_Parms));
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventOnChildGripRelease_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_ReleasingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReleasingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReleasingController, VRGripInterface_eventOnChildGripRelease_Parms), 0x0010000000080080, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered on the interfaced object when child component is released"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_ReleasingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnEndUsed()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnEndUsed"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020800, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Call to stop using an object"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnGrip()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08420800, 65535, sizeof(VRGripInterface_eventOnGrip_Parms));
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventOnGrip_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_GrippingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrippingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(GrippingController, VRGripInterface_eventOnGrip_Parms), 0x0010000000080080, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered on the interfaced object when gripped"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_GrippingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnGripRelease()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnGripRelease"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08420800, 65535, sizeof(VRGripInterface_eventOnGripRelease_Parms));
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventOnGripRelease_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_ReleasingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReleasingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReleasingController, VRGripInterface_eventOnGripRelease_Parms), 0x0010000000080080, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered on the interfaced object when grip is released"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_ReleasingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnSecondaryGrip()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnSecondaryGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08420800, 65535, sizeof(VRGripInterface_eventOnSecondaryGrip_Parms));
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventOnSecondaryGrip_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_SecondaryGripComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SecondaryGripComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(SecondaryGripComponent, VRGripInterface_eventOnSecondaryGrip_Parms), 0x0010000000080080, Z_Construct_UClass_USceneComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered on the interfaced object when secondary gripped"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_SecondaryGripComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnSecondaryGripRelease()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnSecondaryGripRelease"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08420800, 65535, sizeof(VRGripInterface_eventOnSecondaryGripRelease_Parms));
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventOnSecondaryGripRelease_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_ReleasingSecondaryGripComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReleasingSecondaryGripComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReleasingSecondaryGripComponent, VRGripInterface_eventOnSecondaryGripRelease_Parms), 0x0010000000080080, Z_Construct_UClass_USceneComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered on the interfaced object when secondary grip is released"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_ReleasingSecondaryGripComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnUsed()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnUsed"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020800, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Call to use an object"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_SimulateOnDrop()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SimulateOnDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(VRGripInterface_eventSimulateOnDrop_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRGripInterface_eventSimulateOnDrop_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRGripInterface_eventSimulateOnDrop_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRGripInterface_eventSimulateOnDrop_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Should this object simulate on drop"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_SlotGripType()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SlotGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(VRGripInterface_eventSlotGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventSlotGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_TeleportBehavior()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TeleportBehavior"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(VRGripInterface_eventTeleportBehavior_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventTeleportBehavior_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("How an interfaced object behaves when teleporting"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_TickGrip()
	{
		UObject* Outer=Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TickGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08C20800, 65535, sizeof(VRGripInterface_eventTickGrip_Parms));
			UProperty* NewProp_DeltaTime = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeltaTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DeltaTime, VRGripInterface_eventTickGrip_Parms), 0x0010000000000080);
			UProperty* NewProp_MControllerLocDelta = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MControllerLocDelta"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(MControllerLocDelta, VRGripInterface_eventTickGrip_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventTickGrip_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_GrippingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrippingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(GrippingController, VRGripInterface_eventTickGrip_Parms), 0x0010000000080080, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered each tick on the interfaced object when gripped, can be used for custom movement or grip based logic"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_GrippingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UVRGripInterface_NoRegister()
	{
		return UVRGripInterface::StaticClass();
	}
	UClass* Z_Construct_UClass_UVRGripInterface()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UVRGripInterface::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_CanHaveDoubleGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_ClosestPrimarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_ClosestSecondarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_DenyGripping());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_FreeGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_GetInteractionSettings());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_GripBreakDistance());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_GripDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_GripLateUpdateSetting());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_GripMovementReplicationType());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_GripStiffness());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_IsInteractible());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_ObjectType());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnChildGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnChildGripRelease());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnEndUsed());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnGripRelease());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnSecondaryGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnSecondaryGripRelease());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnUsed());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_SimulateOnDrop());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_SlotGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_TeleportBehavior());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_TickGrip());

				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_CanHaveDoubleGrip(), "CanHaveDoubleGrip"); // 1922780443
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_ClosestPrimarySlotInRange(), "ClosestPrimarySlotInRange"); // 1534839380
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_ClosestSecondarySlotInRange(), "ClosestSecondarySlotInRange"); // 1212777775
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_DenyGripping(), "DenyGripping"); // 2758783327
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_FreeGripType(), "FreeGripType"); // 2266305963
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_GetInteractionSettings(), "GetInteractionSettings"); // 1518132457
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_GripBreakDistance(), "GripBreakDistance"); // 237591278
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_GripDamping(), "GripDamping"); // 1296146785
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_GripLateUpdateSetting(), "GripLateUpdateSetting"); // 2309341282
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_GripMovementReplicationType(), "GripMovementReplicationType"); // 3678175154
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_GripStiffness(), "GripStiffness"); // 1143431733
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_IsInteractible(), "IsInteractible"); // 1438517457
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_ObjectType(), "ObjectType"); // 324559337
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnChildGrip(), "OnChildGrip"); // 1746377832
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnChildGripRelease(), "OnChildGripRelease"); // 2721159967
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnEndUsed(), "OnEndUsed"); // 1590613280
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnGrip(), "OnGrip"); // 1509014108
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnGripRelease(), "OnGripRelease"); // 3857270088
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnSecondaryGrip(), "OnSecondaryGrip"); // 216608663
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnSecondaryGripRelease(), "OnSecondaryGripRelease"); // 1490745808
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnUsed(), "OnUsed"); // 4040810452
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_SimulateOnDrop(), "SimulateOnDrop"); // 2206462145
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_SlotGripType(), "SlotGripType"); // 2553767056
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_TeleportBehavior(), "TeleportBehavior"); // 276788438
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_TickGrip(), "TickGrip"); // 3809223621
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UVRGripInterface(Z_Construct_UClass_UVRGripInterface, &UVRGripInterface::StaticClass, TEXT("UVRGripInterface"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UVRGripInterface);
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_AddSecondaryAttachmentPoint()
	{
		struct GripMotionControllerComponent_eventAddSecondaryAttachmentPoint_Parms
		{
			AActor* GrippedActorToAddAttachment;
			USceneComponent* SecondaryPointComponent;
			FTransform OriginalTransform;
			bool bTransformIsAlreadyRelative;
			float LerpToTime;
			float SecondarySmoothingScaler;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddSecondaryAttachmentPoint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(GripMotionControllerComponent_eventAddSecondaryAttachmentPoint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventAddSecondaryAttachmentPoint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventAddSecondaryAttachmentPoint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventAddSecondaryAttachmentPoint_Parms), sizeof(bool), true);
			UProperty* NewProp_SecondarySmoothingScaler = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SecondarySmoothingScaler"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SecondarySmoothingScaler, GripMotionControllerComponent_eventAddSecondaryAttachmentPoint_Parms), 0x0010000000000080);
			UProperty* NewProp_LerpToTime = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LerpToTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LerpToTime, GripMotionControllerComponent_eventAddSecondaryAttachmentPoint_Parms), 0x0010000000000080);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bTransformIsAlreadyRelative, GripMotionControllerComponent_eventAddSecondaryAttachmentPoint_Parms, bool);
			UProperty* NewProp_bTransformIsAlreadyRelative = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bTransformIsAlreadyRelative"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bTransformIsAlreadyRelative, GripMotionControllerComponent_eventAddSecondaryAttachmentPoint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bTransformIsAlreadyRelative, GripMotionControllerComponent_eventAddSecondaryAttachmentPoint_Parms), sizeof(bool), true);
			UProperty* NewProp_OriginalTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OriginalTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OriginalTransform, GripMotionControllerComponent_eventAddSecondaryAttachmentPoint_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_SecondaryPointComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SecondaryPointComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(SecondaryPointComponent, GripMotionControllerComponent_eventAddSecondaryAttachmentPoint_Parms), 0x0010000000080080, Z_Construct_UClass_USceneComponent_NoRegister());
			UProperty* NewProp_GrippedActorToAddAttachment = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrippedActorToAddAttachment"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(GrippedActorToAddAttachment, GripMotionControllerComponent_eventAddSecondaryAttachmentPoint_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bTransformIsAlreadyRelative"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_LerpToTime"), TEXT("0.250000"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_SecondarySmoothingScaler"), TEXT("1.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds a secondary attachment point to the grip"));
			MetaData->SetValue(NewProp_OriginalTransform, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_SecondaryPointComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_ConvertToControllerRelativeTransform()
	{
		struct GripMotionControllerComponent_eventConvertToControllerRelativeTransform_Parms
		{
			FTransform InTransform;
			UObject* OptionalObjectToCheck;
			FTransform ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConvertToControllerRelativeTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14C20401, 65535, sizeof(GripMotionControllerComponent_eventConvertToControllerRelativeTransform_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, GripMotionControllerComponent_eventConvertToControllerRelativeTransform_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_OptionalObjectToCheck = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalObjectToCheck"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OptionalObjectToCheck, GripMotionControllerComponent_eventConvertToControllerRelativeTransform_Parms), 0x0010000000000080, Z_Construct_UClass_UObject_NoRegister());
			UProperty* NewProp_InTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InTransform, GripMotionControllerComponent_eventConvertToControllerRelativeTransform_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Converts a worldspace transform into being relative to this motion controller, optionally can check interface settings for a given object as well to modify the given transform"));
			MetaData->SetValue(NewProp_InTransform, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_ConvertToGripRelativeTransform()
	{
		struct GripMotionControllerComponent_eventConvertToGripRelativeTransform_Parms
		{
			FTransform GrippedActorTransform;
			FTransform InTransform;
			FTransform ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConvertToGripRelativeTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(GripMotionControllerComponent_eventConvertToGripRelativeTransform_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, GripMotionControllerComponent_eventConvertToGripRelativeTransform_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_InTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InTransform, GripMotionControllerComponent_eventConvertToGripRelativeTransform_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_GrippedActorTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrippedActorTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GrippedActorTransform, GripMotionControllerComponent_eventConvertToGripRelativeTransform_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Creates a secondary grip relative transform"));
			MetaData->SetValue(NewProp_InTransform, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_GrippedActorTransform, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_CreateGripRelativeAdditionTransform_BP()
	{
		struct GripMotionControllerComponent_eventCreateGripRelativeAdditionTransform_BP_Parms
		{
			FBPActorGripInformation GripToSample;
			FTransform AdditionTransform;
			bool bGripRelative;
			FTransform ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CreateGripRelativeAdditionTransform_BP"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14C20401, 65535, sizeof(GripMotionControllerComponent_eventCreateGripRelativeAdditionTransform_BP_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, GripMotionControllerComponent_eventCreateGripRelativeAdditionTransform_BP_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bGripRelative, GripMotionControllerComponent_eventCreateGripRelativeAdditionTransform_BP_Parms, bool);
			UProperty* NewProp_bGripRelative = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bGripRelative"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bGripRelative, GripMotionControllerComponent_eventCreateGripRelativeAdditionTransform_BP_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bGripRelative, GripMotionControllerComponent_eventCreateGripRelativeAdditionTransform_BP_Parms), sizeof(bool), true);
			UProperty* NewProp_AdditionTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AdditionTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(AdditionTransform, GripMotionControllerComponent_eventCreateGripRelativeAdditionTransform_BP_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_GripToSample = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripToSample"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripToSample, GripMotionControllerComponent_eventCreateGripRelativeAdditionTransform_BP_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bGripRelative"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("CreateGripRelativeAdditionTransform"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Used to convert an offset transform to grip relative, useful for storing an initial offset and then lerping back to 0 without re-calculating every tick"));
			MetaData->SetValue(NewProp_AdditionTransform, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_GripToSample, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_DropActor()
	{
		struct GripMotionControllerComponent_eventDropActor_Parms
		{
			AActor* ActorToDrop;
			bool bSimulate;
			FVector OptionalAngularVelocity;
			FVector OptionalLinearVelocity;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DropActor"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(GripMotionControllerComponent_eventDropActor_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventDropActor_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventDropActor_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventDropActor_Parms), sizeof(bool), true);
			UProperty* NewProp_OptionalLinearVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalLinearVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OptionalLinearVelocity, GripMotionControllerComponent_eventDropActor_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OptionalAngularVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalAngularVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OptionalAngularVelocity, GripMotionControllerComponent_eventDropActor_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSimulate, GripMotionControllerComponent_eventDropActor_Parms, bool);
			UProperty* NewProp_bSimulate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSimulate"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSimulate, GripMotionControllerComponent_eventDropActor_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bSimulate, GripMotionControllerComponent_eventDropActor_Parms), sizeof(bool), true);
			UProperty* NewProp_ActorToDrop = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorToDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ActorToDrop, GripMotionControllerComponent_eventDropActor_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Drop a gripped actor"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_DropComponent()
	{
		struct GripMotionControllerComponent_eventDropComponent_Parms
		{
			UPrimitiveComponent* ComponentToDrop;
			bool bSimulate;
			FVector OptionalAngularVelocity;
			FVector OptionalLinearVelocity;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DropComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(GripMotionControllerComponent_eventDropComponent_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventDropComponent_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventDropComponent_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventDropComponent_Parms), sizeof(bool), true);
			UProperty* NewProp_OptionalLinearVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalLinearVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OptionalLinearVelocity, GripMotionControllerComponent_eventDropComponent_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OptionalAngularVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalAngularVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OptionalAngularVelocity, GripMotionControllerComponent_eventDropComponent_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSimulate, GripMotionControllerComponent_eventDropComponent_Parms, bool);
			UProperty* NewProp_bSimulate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSimulate"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSimulate, GripMotionControllerComponent_eventDropComponent_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bSimulate, GripMotionControllerComponent_eventDropComponent_Parms), sizeof(bool), true);
			UProperty* NewProp_ComponentToDrop = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ComponentToDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ComponentToDrop, GripMotionControllerComponent_eventDropComponent_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Drop a gripped component"));
			MetaData->SetValue(NewProp_ComponentToDrop, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_DropGrip()
	{
		struct GripMotionControllerComponent_eventDropGrip_Parms
		{
			FBPActorGripInformation Grip;
			bool bSimulate;
			FVector OptionalAngularVelocity;
			FVector OptionalLinearVelocity;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DropGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(GripMotionControllerComponent_eventDropGrip_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventDropGrip_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventDropGrip_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventDropGrip_Parms), sizeof(bool), true);
			UProperty* NewProp_OptionalLinearVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalLinearVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OptionalLinearVelocity, GripMotionControllerComponent_eventDropGrip_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OptionalAngularVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalAngularVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OptionalAngularVelocity, GripMotionControllerComponent_eventDropGrip_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSimulate, GripMotionControllerComponent_eventDropGrip_Parms, bool);
			UProperty* NewProp_bSimulate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSimulate"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSimulate, GripMotionControllerComponent_eventDropGrip_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bSimulate, GripMotionControllerComponent_eventDropGrip_Parms), sizeof(bool), true);
			UProperty* NewProp_Grip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Grip"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Grip, GripMotionControllerComponent_eventDropGrip_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Master function for dropping a grip"));
			MetaData->SetValue(NewProp_Grip, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_DropObject()
	{
		struct GripMotionControllerComponent_eventDropObject_Parms
		{
			UObject* ObjectToDrop;
			bool bSimulate;
			FVector OptionalAngularVelocity;
			FVector OptionalLinearVelocity;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DropObject"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(GripMotionControllerComponent_eventDropObject_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventDropObject_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventDropObject_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventDropObject_Parms), sizeof(bool), true);
			UProperty* NewProp_OptionalLinearVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalLinearVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OptionalLinearVelocity, GripMotionControllerComponent_eventDropObject_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OptionalAngularVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalAngularVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OptionalAngularVelocity, GripMotionControllerComponent_eventDropObject_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSimulate, GripMotionControllerComponent_eventDropObject_Parms, bool);
			UProperty* NewProp_bSimulate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSimulate"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSimulate, GripMotionControllerComponent_eventDropObject_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bSimulate, GripMotionControllerComponent_eventDropObject_Parms), sizeof(bool), true);
			UProperty* NewProp_ObjectToDrop = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectToDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ObjectToDrop, GripMotionControllerComponent_eventDropObject_Parms), 0x0010000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Auto drop any uobject that is/root is a primitive component and has the VR Grip Interface"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_DropObjectByInterface()
	{
		struct GripMotionControllerComponent_eventDropObjectByInterface_Parms
		{
			UObject* ObjectToDrop;
			FVector OptionalAngularVelocity;
			FVector OptionalLinearVelocity;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DropObjectByInterface"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(GripMotionControllerComponent_eventDropObjectByInterface_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventDropObjectByInterface_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventDropObjectByInterface_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventDropObjectByInterface_Parms), sizeof(bool), true);
			UProperty* NewProp_OptionalLinearVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalLinearVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OptionalLinearVelocity, GripMotionControllerComponent_eventDropObjectByInterface_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OptionalAngularVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalAngularVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OptionalAngularVelocity, GripMotionControllerComponent_eventDropObjectByInterface_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ObjectToDrop = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectToDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ObjectToDrop, GripMotionControllerComponent_eventDropObjectByInterface_Parms), 0x0010000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Auto drop any uobject that is/root is a primitive component and has the VR Grip Interface"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetGripByActor()
	{
		struct GripMotionControllerComponent_eventGetGripByActor_Parms
		{
			FBPActorGripInformation Grip;
			AActor* ActorToLookForGrip;
			TEnumAsByte<EBPVRResultSwitch::Type> Result;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetGripByActor"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(GripMotionControllerComponent_eventGetGripByActor_Parms));
			UProperty* NewProp_Result = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Result"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Result, GripMotionControllerComponent_eventGetGripByActor_Parms), 0x0010000000000180, Z_Construct_UEnum_VRExpansionPlugin_EBPVRResultSwitch());
			UProperty* NewProp_ActorToLookForGrip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorToLookForGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ActorToLookForGrip, GripMotionControllerComponent_eventGetGripByActor_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_Grip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Grip"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Grip, GripMotionControllerComponent_eventGetGripByActor_Parms), 0x0010008000000180, Z_Construct_UScriptStruct_FBPActorGripInformation());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ExpandEnumAsExecs"), TEXT("Result"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get a grip by actor"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetGripByComponent()
	{
		struct GripMotionControllerComponent_eventGetGripByComponent_Parms
		{
			FBPActorGripInformation Grip;
			UPrimitiveComponent* ComponentToLookForGrip;
			TEnumAsByte<EBPVRResultSwitch::Type> Result;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetGripByComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(GripMotionControllerComponent_eventGetGripByComponent_Parms));
			UProperty* NewProp_Result = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Result"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Result, GripMotionControllerComponent_eventGetGripByComponent_Parms), 0x0010000000000180, Z_Construct_UEnum_VRExpansionPlugin_EBPVRResultSwitch());
			UProperty* NewProp_ComponentToLookForGrip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ComponentToLookForGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ComponentToLookForGrip, GripMotionControllerComponent_eventGetGripByComponent_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_Grip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Grip"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Grip, GripMotionControllerComponent_eventGetGripByComponent_Parms), 0x0010008000000180, Z_Construct_UScriptStruct_FBPActorGripInformation());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ExpandEnumAsExecs"), TEXT("Result"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get a grip by component"));
			MetaData->SetValue(NewProp_ComponentToLookForGrip, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetGrippedActors()
	{
		struct GripMotionControllerComponent_eventGetGrippedActors_Parms
		{
			TArray<AActor*> GrippedActorsArray;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetGrippedActors"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(GripMotionControllerComponent_eventGetGrippedActors_Parms));
			UProperty* NewProp_GrippedActorsArray = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrippedActorsArray"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(GrippedActorsArray, GripMotionControllerComponent_eventGetGrippedActors_Parms), 0x0010000000000180);
			UProperty* NewProp_GrippedActorsArray_Inner = new(EC_InternalUseOnlyConstructor, NewProp_GrippedActorsArray, TEXT("GrippedActorsArray"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get list of all gripped actors"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetGrippedComponents()
	{
		struct GripMotionControllerComponent_eventGetGrippedComponents_Parms
		{
			TArray<UPrimitiveComponent*> GrippedComponentsArray;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetGrippedComponents"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(GripMotionControllerComponent_eventGetGrippedComponents_Parms));
			UProperty* NewProp_GrippedComponentsArray = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrippedComponentsArray"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(GrippedComponentsArray, GripMotionControllerComponent_eventGetGrippedComponents_Parms), 0x0010008000000180);
			UProperty* NewProp_GrippedComponentsArray_Inner = new(EC_InternalUseOnlyConstructor, NewProp_GrippedComponentsArray, TEXT("GrippedComponentsArray"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000080000, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get list of all gripped components"));
			MetaData->SetValue(NewProp_GrippedComponentsArray, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetIsComponentHeld()
	{
		struct GripMotionControllerComponent_eventGetIsComponentHeld_Parms
		{
			const UPrimitiveComponent* ComponentToCheck;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetIsComponentHeld"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14020401, 65535, sizeof(GripMotionControllerComponent_eventGetIsComponentHeld_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventGetIsComponentHeld_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventGetIsComponentHeld_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventGetIsComponentHeld_Parms), sizeof(bool), true);
			UProperty* NewProp_ComponentToCheck = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ComponentToCheck"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ComponentToCheck, GripMotionControllerComponent_eventGetIsComponentHeld_Parms), 0x0010000000080082, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets if the given Component is a secondary attach point to a gripped actor"));
			MetaData->SetValue(NewProp_ComponentToCheck, TEXT("EditInline"), TEXT("true"));
			MetaData->SetValue(NewProp_ComponentToCheck, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetIsHeld()
	{
		struct GripMotionControllerComponent_eventGetIsHeld_Parms
		{
			const AActor* ActorToCheck;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetIsHeld"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14020401, 65535, sizeof(GripMotionControllerComponent_eventGetIsHeld_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventGetIsHeld_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventGetIsHeld_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventGetIsHeld_Parms), sizeof(bool), true);
			UProperty* NewProp_ActorToCheck = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorToCheck"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ActorToCheck, GripMotionControllerComponent_eventGetIsHeld_Parms), 0x0010000000000082, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets if the given Component is a secondary attach point to a gripped actor"));
			MetaData->SetValue(NewProp_ActorToCheck, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetIsObjectHeld()
	{
		struct GripMotionControllerComponent_eventGetIsObjectHeld_Parms
		{
			const UObject* ObjectToCheck;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetIsObjectHeld"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14020401, 65535, sizeof(GripMotionControllerComponent_eventGetIsObjectHeld_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventGetIsObjectHeld_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventGetIsObjectHeld_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventGetIsObjectHeld_Parms), sizeof(bool), true);
			UProperty* NewProp_ObjectToCheck = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectToCheck"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ObjectToCheck, GripMotionControllerComponent_eventGetIsObjectHeld_Parms), 0x0010000000000082, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets if the given Component is a secondary attach point to a gripped actor"));
			MetaData->SetValue(NewProp_ObjectToCheck, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetIsSecondaryAttachment()
	{
		struct GripMotionControllerComponent_eventGetIsSecondaryAttachment_Parms
		{
			const USceneComponent* ComponentToCheck;
			FBPActorGripInformation Grip;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetIsSecondaryAttachment"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14420401, 65535, sizeof(GripMotionControllerComponent_eventGetIsSecondaryAttachment_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventGetIsSecondaryAttachment_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventGetIsSecondaryAttachment_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventGetIsSecondaryAttachment_Parms), sizeof(bool), true);
			UProperty* NewProp_Grip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Grip"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Grip, GripMotionControllerComponent_eventGetIsSecondaryAttachment_Parms), 0x0010008000000180, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_ComponentToCheck = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ComponentToCheck"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ComponentToCheck, GripMotionControllerComponent_eventGetIsSecondaryAttachment_Parms), 0x0010000000080082, Z_Construct_UClass_USceneComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets if the given Component is a secondary attach point to a gripped actor"));
			MetaData->SetValue(NewProp_ComponentToCheck, TEXT("EditInline"), TEXT("true"));
			MetaData->SetValue(NewProp_ComponentToCheck, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GetPhysicsVelocities()
	{
		struct GripMotionControllerComponent_eventGetPhysicsVelocities_Parms
		{
			FBPActorGripInformation Grip;
			FVector AngularVelocity;
			FVector LinearVelocity;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPhysicsVelocities"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14C20401, 65535, sizeof(GripMotionControllerComponent_eventGetPhysicsVelocities_Parms));
			UProperty* NewProp_LinearVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LinearVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LinearVelocity, GripMotionControllerComponent_eventGetPhysicsVelocities_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_AngularVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AngularVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(AngularVelocity, GripMotionControllerComponent_eventGetPhysicsVelocities_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Grip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Grip"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Grip, GripMotionControllerComponent_eventGetPhysicsVelocities_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the physics velocities of a grip"));
			MetaData->SetValue(NewProp_Grip, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GripActor()
	{
		struct GripMotionControllerComponent_eventGripActor_Parms
		{
			AActor* ActorToGrip;
			FTransform WorldOffset;
			bool bWorldOffsetIsRelative;
			FName OptionalSnapToSocketName;
			TEnumAsByte<EGripCollisionType> GripCollisionType;
			TEnumAsByte<EGripLateUpdateSettings> GripLateUpdateSetting;
			TEnumAsByte<EGripMovementReplicationSettings> GripMovementReplicationSetting;
			float GripStiffness;
			float GripDamping;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripActor"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(GripMotionControllerComponent_eventGripActor_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventGripActor_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventGripActor_Parms), sizeof(bool), true);
			UProperty* NewProp_GripDamping = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(GripDamping, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080);
			UProperty* NewProp_GripStiffness = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(GripStiffness, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080);
			UProperty* NewProp_GripMovementReplicationSetting = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripMovementReplicationSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GripMovementReplicationSetting, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			UProperty* NewProp_GripLateUpdateSetting = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GripLateUpdateSetting, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			UProperty* NewProp_GripCollisionType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripCollisionType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GripCollisionType, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			UProperty* NewProp_OptionalSnapToSocketName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalSnapToSocketName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(OptionalSnapToSocketName, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripActor_Parms, bool);
			UProperty* NewProp_bWorldOffsetIsRelative = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bWorldOffsetIsRelative"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripActor_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldOffset = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldOffset, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_ActorToGrip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorToGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ActorToGrip, GripMotionControllerComponent_eventGripActor_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bWorldOffsetIsRelative"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripCollisionType"), TEXT("InteractiveCollisionWithPhysics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripDamping"), TEXT("200.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripLateUpdateSetting"), TEXT("NotWhenCollidingOrDoubleGripping"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripMovementReplicationSetting"), TEXT("ForceClientSideMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripStiffness"), TEXT("1500.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_OptionalSnapToSocketName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip an actor, these are stored in a Tarray that will prevent destruction of the object, you MUST ungrip an actor if you want to kill it\n         The WorldOffset is the transform that it will remain away from the controller, if you use the world position of the actor then it will grab\n         at the point of intersection.\n\n         If WorldOffsetIsRelative is true then it will not convert the transform from world space but will instead use that offset directly.\n         You could pass in a socket relative transform with this set for snapping or an empty transform to snap the object at its 0,0,0 point.\n\n         If you declare a valid OptionSnapToSocketName then it will instead snap the actor to the relative offset\n         location that the socket is to its parent actor."));
			MetaData->SetValue(NewProp_WorldOffset, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GripComponent()
	{
		struct GripMotionControllerComponent_eventGripComponent_Parms
		{
			UPrimitiveComponent* ComponentToGrip;
			FTransform WorldOffset;
			bool bWorldOffsetIsRelative;
			FName OptionalSnapToSocketName;
			TEnumAsByte<EGripCollisionType> GripCollisionType;
			TEnumAsByte<EGripLateUpdateSettings> GripLateUpdateSetting;
			TEnumAsByte<EGripMovementReplicationSettings> GripMovementReplicationSetting;
			float GripStiffness;
			float GripDamping;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(GripMotionControllerComponent_eventGripComponent_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventGripComponent_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventGripComponent_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventGripComponent_Parms), sizeof(bool), true);
			UProperty* NewProp_GripDamping = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(GripDamping, GripMotionControllerComponent_eventGripComponent_Parms), 0x0010000000000080);
			UProperty* NewProp_GripStiffness = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(GripStiffness, GripMotionControllerComponent_eventGripComponent_Parms), 0x0010000000000080);
			UProperty* NewProp_GripMovementReplicationSetting = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripMovementReplicationSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GripMovementReplicationSetting, GripMotionControllerComponent_eventGripComponent_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			UProperty* NewProp_GripLateUpdateSetting = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GripLateUpdateSetting, GripMotionControllerComponent_eventGripComponent_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			UProperty* NewProp_GripCollisionType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripCollisionType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GripCollisionType, GripMotionControllerComponent_eventGripComponent_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			UProperty* NewProp_OptionalSnapToSocketName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalSnapToSocketName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(OptionalSnapToSocketName, GripMotionControllerComponent_eventGripComponent_Parms), 0x0010000000000080);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripComponent_Parms, bool);
			UProperty* NewProp_bWorldOffsetIsRelative = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bWorldOffsetIsRelative"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripComponent_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripComponent_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldOffset = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldOffset, GripMotionControllerComponent_eventGripComponent_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_ComponentToGrip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ComponentToGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ComponentToGrip, GripMotionControllerComponent_eventGripComponent_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bWorldOffsetIsRelative"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripCollisionType"), TEXT("InteractiveCollisionWithPhysics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripDamping"), TEXT("200.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripLateUpdateSetting"), TEXT("NotWhenCollidingOrDoubleGripping"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripMovementReplicationSetting"), TEXT("ForceClientSideMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripStiffness"), TEXT("1500.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_OptionalSnapToSocketName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip a component"));
			MetaData->SetValue(NewProp_WorldOffset, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_ComponentToGrip, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GripObject()
	{
		struct GripMotionControllerComponent_eventGripObject_Parms
		{
			UObject* ObjectToGrip;
			FTransform WorldOffset;
			bool bWorldOffsetIsRelative;
			FName OptionalSnapToSocketName;
			TEnumAsByte<EGripCollisionType> GripCollisionType;
			TEnumAsByte<EGripLateUpdateSettings> GripLateUpdateSetting;
			TEnumAsByte<EGripMovementReplicationSettings> GripMovementReplicationSetting;
			float GripStiffness;
			float GripDamping;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripObject"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(GripMotionControllerComponent_eventGripObject_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventGripObject_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventGripObject_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventGripObject_Parms), sizeof(bool), true);
			UProperty* NewProp_GripDamping = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(GripDamping, GripMotionControllerComponent_eventGripObject_Parms), 0x0010000000000080);
			UProperty* NewProp_GripStiffness = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(GripStiffness, GripMotionControllerComponent_eventGripObject_Parms), 0x0010000000000080);
			UProperty* NewProp_GripMovementReplicationSetting = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripMovementReplicationSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GripMovementReplicationSetting, GripMotionControllerComponent_eventGripObject_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			UProperty* NewProp_GripLateUpdateSetting = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GripLateUpdateSetting, GripMotionControllerComponent_eventGripObject_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			UProperty* NewProp_GripCollisionType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripCollisionType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GripCollisionType, GripMotionControllerComponent_eventGripObject_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			UProperty* NewProp_OptionalSnapToSocketName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OptionalSnapToSocketName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(OptionalSnapToSocketName, GripMotionControllerComponent_eventGripObject_Parms), 0x0010000000000080);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripObject_Parms, bool);
			UProperty* NewProp_bWorldOffsetIsRelative = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bWorldOffsetIsRelative"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripObject_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripObject_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldOffset = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldOffset, GripMotionControllerComponent_eventGripObject_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_ObjectToGrip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectToGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ObjectToGrip, GripMotionControllerComponent_eventGripObject_Parms), 0x0010000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bWorldOffsetIsRelative"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripCollisionType"), TEXT("InteractiveCollisionWithPhysics"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripDamping"), TEXT("200.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripLateUpdateSetting"), TEXT("NotWhenCollidingOrDoubleGripping"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripMovementReplicationSetting"), TEXT("ForceClientSideMovement"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_GripStiffness"), TEXT("1500.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_OptionalSnapToSocketName"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Auto grip any uobject that is/root is a primitive component and has the VR Grip Interface"));
			MetaData->SetValue(NewProp_WorldOffset, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_GripObjectByInterface()
	{
		struct GripMotionControllerComponent_eventGripObjectByInterface_Parms
		{
			UObject* ObjectToGrip;
			FTransform WorldOffset;
			bool bWorldOffsetIsRelative;
			bool bIsSlotGrip;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripObjectByInterface"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(GripMotionControllerComponent_eventGripObjectByInterface_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventGripObjectByInterface_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventGripObjectByInterface_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventGripObjectByInterface_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsSlotGrip, GripMotionControllerComponent_eventGripObjectByInterface_Parms, bool);
			UProperty* NewProp_bIsSlotGrip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIsSlotGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsSlotGrip, GripMotionControllerComponent_eventGripObjectByInterface_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIsSlotGrip, GripMotionControllerComponent_eventGripObjectByInterface_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripObjectByInterface_Parms, bool);
			UProperty* NewProp_bWorldOffsetIsRelative = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bWorldOffsetIsRelative"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripObjectByInterface_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bWorldOffsetIsRelative, GripMotionControllerComponent_eventGripObjectByInterface_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldOffset = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldOffset, GripMotionControllerComponent_eventGripObjectByInterface_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_ObjectToGrip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectToGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ObjectToGrip, GripMotionControllerComponent_eventGripObjectByInterface_Parms), 0x0010000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bIsSlotGrip"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bWorldOffsetIsRelative"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Auto grip any uobject that is/root is a primitive component"));
			MetaData->SetValue(NewProp_WorldOffset, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_IsTracked()
	{
		struct GripMotionControllerComponent_eventIsTracked_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsTracked"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(GripMotionControllerComponent_eventIsTracked_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventIsTracked_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventIsTracked_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventIsTracked_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MotionController"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Whether or not this component had a valid tracked device this frame"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_NotifyDrop()
	{
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("NotifyDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00024CC0, 65535, sizeof(GripMotionControllerComponent_eventNotifyDrop_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bSimulate, GripMotionControllerComponent_eventNotifyDrop_Parms, bool);
			UProperty* NewProp_bSimulate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bSimulate"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bSimulate, GripMotionControllerComponent_eventNotifyDrop_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bSimulate, GripMotionControllerComponent_eventNotifyDrop_Parms), sizeof(bool), true);
			UProperty* NewProp_NewDrop = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(NewDrop, GripMotionControllerComponent_eventNotifyDrop_Parms), 0x0010008008000082, Z_Construct_UScriptStruct_FBPActorGripInformation());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(NewProp_NewDrop, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_OnRep_GrippedActors()
	{
		struct GripMotionControllerComponent_eventOnRep_GrippedActors_Parms
		{
			TArray<FBPActorGripInformation> OriginalArrayState;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_GrippedActors"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00020400, 65535, sizeof(GripMotionControllerComponent_eventOnRep_GrippedActors_Parms));
			UProperty* NewProp_OriginalArrayState = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OriginalArrayState"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(OriginalArrayState, GripMotionControllerComponent_eventOnRep_GrippedActors_Parms), 0x0010008000000080);
			UProperty* NewProp_OriginalArrayState_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OriginalArrayState, TEXT("OriginalArrayState"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FBPActorGripInformation());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_OnRep_ReplicatedControllerTransform()
	{
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_ReplicatedControllerTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_PostTeleportMoveGrippedActors()
	{
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PostTeleportMoveGrippedActors"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("After teleporting a pawn you NEED to call this, otherwise gripped objects will travel with a sweeped move and can get caught on geometry"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_RemoveSecondaryAttachmentPoint()
	{
		struct GripMotionControllerComponent_eventRemoveSecondaryAttachmentPoint_Parms
		{
			AActor* GrippedActorToRemoveAttachment;
			float LerpToTime;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RemoveSecondaryAttachmentPoint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(GripMotionControllerComponent_eventRemoveSecondaryAttachmentPoint_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventRemoveSecondaryAttachmentPoint_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventRemoveSecondaryAttachmentPoint_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventRemoveSecondaryAttachmentPoint_Parms), sizeof(bool), true);
			UProperty* NewProp_LerpToTime = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LerpToTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LerpToTime, GripMotionControllerComponent_eventRemoveSecondaryAttachmentPoint_Parms), 0x0010000000000080);
			UProperty* NewProp_GrippedActorToRemoveAttachment = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrippedActorToRemoveAttachment"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(GrippedActorToRemoveAttachment, GripMotionControllerComponent_eventRemoveSecondaryAttachmentPoint_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_LerpToTime"), TEXT("0.250000"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Adds a secondary attachment point to the grip"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_Server_SendControllerTransform()
	{
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Server_SendControllerTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220C40, 65535, sizeof(GripMotionControllerComponent_eventServer_SendControllerTransform_Parms));
			UProperty* NewProp_NewTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(NewTransform, GripMotionControllerComponent_eventServer_SendControllerTransform_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FBPVRComponentPosRep());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("I'm sending it unreliable because it is being resent pretty often"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_SetGripAdditionTransform()
	{
		struct GripMotionControllerComponent_eventSetGripAdditionTransform_Parms
		{
			FBPActorGripInformation Grip;
			TEnumAsByte<EBPVRResultSwitch::Type> Result;
			FTransform NewAdditionTransform;
			bool bMakeGripRelative;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetGripAdditionTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(GripMotionControllerComponent_eventSetGripAdditionTransform_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bMakeGripRelative, GripMotionControllerComponent_eventSetGripAdditionTransform_Parms, bool);
			UProperty* NewProp_bMakeGripRelative = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bMakeGripRelative"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bMakeGripRelative, GripMotionControllerComponent_eventSetGripAdditionTransform_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bMakeGripRelative, GripMotionControllerComponent_eventSetGripAdditionTransform_Parms), sizeof(bool), true);
			UProperty* NewProp_NewAdditionTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewAdditionTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(NewAdditionTransform, GripMotionControllerComponent_eventSetGripAdditionTransform_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_Result = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Result"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Result, GripMotionControllerComponent_eventSetGripAdditionTransform_Parms), 0x0010000000000180, Z_Construct_UEnum_VRExpansionPlugin_EBPVRResultSwitch());
			UProperty* NewProp_Grip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Grip"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Grip, GripMotionControllerComponent_eventSetGripAdditionTransform_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bMakeGripRelative"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ExpandEnumAsExecs"), TEXT("Result"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the addition transform of a grip"));
			MetaData->SetValue(NewProp_NewAdditionTransform, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_Grip, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_SetGripLateUpdateSetting()
	{
		struct GripMotionControllerComponent_eventSetGripLateUpdateSetting_Parms
		{
			FBPActorGripInformation Grip;
			TEnumAsByte<EBPVRResultSwitch::Type> Result;
			TEnumAsByte<EGripLateUpdateSettings> NewGripLateUpdateSetting;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetGripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(GripMotionControllerComponent_eventSetGripLateUpdateSetting_Parms));
			UProperty* NewProp_NewGripLateUpdateSetting = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewGripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(NewGripLateUpdateSetting, GripMotionControllerComponent_eventSetGripLateUpdateSetting_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			UProperty* NewProp_Result = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Result"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Result, GripMotionControllerComponent_eventSetGripLateUpdateSetting_Parms), 0x0010000000000180, Z_Construct_UEnum_VRExpansionPlugin_EBPVRResultSwitch());
			UProperty* NewProp_Grip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Grip"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Grip, GripMotionControllerComponent_eventSetGripLateUpdateSetting_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_NewGripLateUpdateSetting"), TEXT("NotWhenCollidingOrDoubleGripping"));
			MetaData->SetValue(ReturnFunction, TEXT("ExpandEnumAsExecs"), TEXT("Result"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the late update setting of a grip"));
			MetaData->SetValue(NewProp_Grip, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_SetGripRelativeTransform()
	{
		struct GripMotionControllerComponent_eventSetGripRelativeTransform_Parms
		{
			FBPActorGripInformation Grip;
			TEnumAsByte<EBPVRResultSwitch::Type> Result;
			FTransform NewRelativeTransform;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetGripRelativeTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(GripMotionControllerComponent_eventSetGripRelativeTransform_Parms));
			UProperty* NewProp_NewRelativeTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewRelativeTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(NewRelativeTransform, GripMotionControllerComponent_eventSetGripRelativeTransform_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			UProperty* NewProp_Result = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Result"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Result, GripMotionControllerComponent_eventSetGripRelativeTransform_Parms), 0x0010000000000180, Z_Construct_UEnum_VRExpansionPlugin_EBPVRResultSwitch());
			UProperty* NewProp_Grip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Grip"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Grip, GripMotionControllerComponent_eventSetGripRelativeTransform_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ExpandEnumAsExecs"), TEXT("Result"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the relative transform of a grip"));
			MetaData->SetValue(NewProp_NewRelativeTransform, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_Grip, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_TeleportMoveGrip()
	{
		struct GripMotionControllerComponent_eventTeleportMoveGrip_Parms
		{
			FBPActorGripInformation Grip;
			bool bIsPostTeleport;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TeleportMoveGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(GripMotionControllerComponent_eventTeleportMoveGrip_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventTeleportMoveGrip_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventTeleportMoveGrip_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventTeleportMoveGrip_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsPostTeleport, GripMotionControllerComponent_eventTeleportMoveGrip_Parms, bool);
			UProperty* NewProp_bIsPostTeleport = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIsPostTeleport"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsPostTeleport, GripMotionControllerComponent_eventTeleportMoveGrip_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIsPostTeleport, GripMotionControllerComponent_eventTeleportMoveGrip_Parms), sizeof(bool), true);
			UProperty* NewProp_Grip = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Grip"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Grip, GripMotionControllerComponent_eventTeleportMoveGrip_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bIsPostTeleport"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(NewProp_Grip, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_TeleportMoveGrippedActor()
	{
		struct GripMotionControllerComponent_eventTeleportMoveGrippedActor_Parms
		{
			AActor* GrippedActorToMove;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TeleportMoveGrippedActor"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(GripMotionControllerComponent_eventTeleportMoveGrippedActor_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventTeleportMoveGrippedActor_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventTeleportMoveGrippedActor_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventTeleportMoveGrippedActor_Parms), sizeof(bool), true);
			UProperty* NewProp_GrippedActorToMove = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrippedActorToMove"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(GrippedActorToMove, GripMotionControllerComponent_eventTeleportMoveGrippedActor_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Move a single gripped item back into position ignoring collision in the way"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGripMotionControllerComponent_TeleportMoveGrippedComponent()
	{
		struct GripMotionControllerComponent_eventTeleportMoveGrippedComponent_Parms
		{
			UPrimitiveComponent* ComponentToMove;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UGripMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TeleportMoveGrippedComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(GripMotionControllerComponent_eventTeleportMoveGrippedComponent_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GripMotionControllerComponent_eventTeleportMoveGrippedComponent_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GripMotionControllerComponent_eventTeleportMoveGrippedComponent_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GripMotionControllerComponent_eventTeleportMoveGrippedComponent_Parms), sizeof(bool), true);
			UProperty* NewProp_ComponentToMove = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ComponentToMove"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ComponentToMove, GripMotionControllerComponent_eventTeleportMoveGrippedComponent_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Move a single gripped item back into position ignoring collision in the way"));
			MetaData->SetValue(NewProp_ComponentToMove, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UGripMotionControllerComponent_NoRegister()
	{
		return UGripMotionControllerComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UGripMotionControllerComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPrimitiveComponent();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UGripMotionControllerComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_AddSecondaryAttachmentPoint());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_ConvertToControllerRelativeTransform());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_ConvertToGripRelativeTransform());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_CreateGripRelativeAdditionTransform_BP());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_DropActor());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_DropComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_DropGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_DropObject());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_DropObjectByInterface());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GetGripByActor());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GetGripByComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GetGrippedActors());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GetGrippedComponents());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GetIsComponentHeld());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GetIsHeld());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GetIsObjectHeld());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GetIsSecondaryAttachment());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GetPhysicsVelocities());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GripActor());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GripComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GripObject());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_GripObjectByInterface());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_IsTracked());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_NotifyDrop());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_OnRep_GrippedActors());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_OnRep_ReplicatedControllerTransform());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_PostTeleportMoveGrippedActors());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_RemoveSecondaryAttachmentPoint());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_Server_SendControllerTransform());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_SetGripAdditionTransform());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_SetGripLateUpdateSetting());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_SetGripRelativeTransform());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_TeleportMoveGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_TeleportMoveGrippedActor());
				OuterClass->LinkChild(Z_Construct_UFunction_UGripMotionControllerComponent_TeleportMoveGrippedComponent());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseWithoutTracking, UGripMotionControllerComponent, bool);
				UProperty* NewProp_bUseWithoutTracking = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseWithoutTracking"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseWithoutTracking, UGripMotionControllerComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bUseWithoutTracking, UGripMotionControllerComponent), sizeof(bool), true);
				UProperty* NewProp_ControllerNetUpdateRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ControllerNetUpdateRate"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ControllerNetUpdateRate, UGripMotionControllerComponent), 0x0010000000000025);
				UProperty* NewProp_ReplicatedControllerTransform = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReplicatedControllerTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReplicatedControllerTransform, UGripMotionControllerComponent), 0x0010000100000034, Z_Construct_UScriptStruct_FBPVRComponentPosRep());
				NewProp_ReplicatedControllerTransform->RepNotifyFunc = FName(TEXT("OnRep_ReplicatedControllerTransform"));
				UProperty* NewProp_AdditionalLateUpdateComponents = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AdditionalLateUpdateComponents"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(AdditionalLateUpdateComponents, UGripMotionControllerComponent), 0x001000800000000c);
				UProperty* NewProp_AdditionalLateUpdateComponents_Inner = new(EC_InternalUseOnlyConstructor, NewProp_AdditionalLateUpdateComponents, TEXT("AdditionalLateUpdateComponents"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000080008, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAlwaysSendTickGrip, UGripMotionControllerComponent, bool);
				UProperty* NewProp_bAlwaysSendTickGrip = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAlwaysSendTickGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAlwaysSendTickGrip, UGripMotionControllerComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bAlwaysSendTickGrip, UGripMotionControllerComponent), sizeof(bool), true);
				UProperty* NewProp_GrippedActors = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GrippedActors"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(GrippedActors, UGripMotionControllerComponent), 0x0010008100000034);
				NewProp_GrippedActors->RepNotifyFunc = FName(TEXT("OnRep_GrippedActors"));
				UProperty* NewProp_GrippedActors_Inner = new(EC_InternalUseOnlyConstructor, NewProp_GrippedActors, TEXT("GrippedActors"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000008000000000, Z_Construct_UScriptStruct_FBPActorGripInformation());
				UProperty* NewProp_CurrentTrackingStatus = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CurrentTrackingStatus"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CurrentTrackingStatus, UGripMotionControllerComponent), 0x0010000000000014, Z_Construct_UEnum_VRExpansionPlugin_EBPTrackingStatus());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDisableLowLatencyUpdate, UGripMotionControllerComponent, uint8);
				UProperty* NewProp_bDisableLowLatencyUpdate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDisableLowLatencyUpdate"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDisableLowLatencyUpdate, UGripMotionControllerComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bDisableLowLatencyUpdate, UGripMotionControllerComponent), sizeof(uint8), false);
				UProperty* NewProp_Hand = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Hand"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Hand, UGripMotionControllerComponent), 0x0010000000000005, Z_Construct_UEnum_InputCore_EControllerHand());
				UProperty* NewProp_PlayerIndex = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PlayerIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(PlayerIndex, UGripMotionControllerComponent), 0x0010000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_AddSecondaryAttachmentPoint(), "AddSecondaryAttachmentPoint"); // 1159246174
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_ConvertToControllerRelativeTransform(), "ConvertToControllerRelativeTransform"); // 273207671
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_ConvertToGripRelativeTransform(), "ConvertToGripRelativeTransform"); // 543249189
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_CreateGripRelativeAdditionTransform_BP(), "CreateGripRelativeAdditionTransform_BP"); // 1230595557
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_DropActor(), "DropActor"); // 2935416618
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_DropComponent(), "DropComponent"); // 2522045415
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_DropGrip(), "DropGrip"); // 2144538335
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_DropObject(), "DropObject"); // 3124442267
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_DropObjectByInterface(), "DropObjectByInterface"); // 3194863028
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GetGripByActor(), "GetGripByActor"); // 2817070103
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GetGripByComponent(), "GetGripByComponent"); // 4266592401
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GetGrippedActors(), "GetGrippedActors"); // 165937759
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GetGrippedComponents(), "GetGrippedComponents"); // 2498673794
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GetIsComponentHeld(), "GetIsComponentHeld"); // 3973546768
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GetIsHeld(), "GetIsHeld"); // 2291380661
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GetIsObjectHeld(), "GetIsObjectHeld"); // 2735608034
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GetIsSecondaryAttachment(), "GetIsSecondaryAttachment"); // 559379797
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GetPhysicsVelocities(), "GetPhysicsVelocities"); // 943638074
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GripActor(), "GripActor"); // 3237527529
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GripComponent(), "GripComponent"); // 1081969850
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GripObject(), "GripObject"); // 1191064165
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_GripObjectByInterface(), "GripObjectByInterface"); // 901272065
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_IsTracked(), "IsTracked"); // 1675797175
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_NotifyDrop(), "NotifyDrop"); // 3683154930
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_OnRep_GrippedActors(), "OnRep_GrippedActors"); // 1569720650
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_OnRep_ReplicatedControllerTransform(), "OnRep_ReplicatedControllerTransform"); // 2063881313
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_PostTeleportMoveGrippedActors(), "PostTeleportMoveGrippedActors"); // 1247750312
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_RemoveSecondaryAttachmentPoint(), "RemoveSecondaryAttachmentPoint"); // 4288229922
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_Server_SendControllerTransform(), "Server_SendControllerTransform"); // 1897666591
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_SetGripAdditionTransform(), "SetGripAdditionTransform"); // 2715674759
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_SetGripLateUpdateSetting(), "SetGripLateUpdateSetting"); // 4018209168
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_SetGripRelativeTransform(), "SetGripRelativeTransform"); // 2796244149
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_TeleportMoveGrip(), "TeleportMoveGrip"); // 2253256308
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_TeleportMoveGrippedActor(), "TeleportMoveGrippedActor"); // 80106377
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGripMotionControllerComponent_TeleportMoveGrippedComponent(), "TeleportMoveGrippedComponent"); // 653867098
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("MotionController"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility Trigger"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GripMotionControllerComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_bUseWithoutTracking, TEXT("Category"), TEXT("VRGrip"));
				MetaData->SetValue(NewProp_bUseWithoutTracking, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_bUseWithoutTracking, TEXT("ToolTip"), TEXT("This is for testing, setting it to true allows you to test grip with a non VR enabled pawn"));
				MetaData->SetValue(NewProp_ControllerNetUpdateRate, TEXT("Category"), TEXT("VRGrip"));
				MetaData->SetValue(NewProp_ControllerNetUpdateRate, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_ControllerNetUpdateRate, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_ControllerNetUpdateRate, TEXT("ToolTip"), TEXT("Rate to update the position to the server, 100htz is default (same as replication rate, should also hit every tick)."));
				MetaData->SetValue(NewProp_ControllerNetUpdateRate, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_ReplicatedControllerTransform, TEXT("Category"), TEXT("VRGrip"));
				MetaData->SetValue(NewProp_ReplicatedControllerTransform, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_ReplicatedControllerTransform, TEXT("ToolTip"), TEXT("Movement Replication\nActor needs to be replicated for this to work"));
				MetaData->SetValue(NewProp_AdditionalLateUpdateComponents, TEXT("Category"), TEXT("VRGrip"));
				MetaData->SetValue(NewProp_AdditionalLateUpdateComponents, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_AdditionalLateUpdateComponents, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_bAlwaysSendTickGrip, TEXT("Category"), TEXT("VRGrip"));
				MetaData->SetValue(NewProp_bAlwaysSendTickGrip, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_bAlwaysSendTickGrip, TEXT("ToolTip"), TEXT("Enable this to send the TickGrip event every tick even for non custom grip types - has a slight performance hit"));
				MetaData->SetValue(NewProp_GrippedActors, TEXT("Category"), TEXT("VRGrip"));
				MetaData->SetValue(NewProp_GrippedActors, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_CurrentTrackingStatus, TEXT("Category"), TEXT("MotionController"));
				MetaData->SetValue(NewProp_CurrentTrackingStatus, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_CurrentTrackingStatus, TEXT("ToolTip"), TEXT("The tracking status for the device (e.g. full tracking, inertial tracking only, no tracking)"));
				MetaData->SetValue(NewProp_bDisableLowLatencyUpdate, TEXT("Category"), TEXT("MotionController"));
				MetaData->SetValue(NewProp_bDisableLowLatencyUpdate, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_bDisableLowLatencyUpdate, TEXT("ToolTip"), TEXT("If false, render transforms within the motion controller hierarchy will be updated a second time immediately before rendering."));
				MetaData->SetValue(NewProp_Hand, TEXT("Category"), TEXT("MotionController"));
				MetaData->SetValue(NewProp_Hand, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_Hand, TEXT("ToolTip"), TEXT("Which hand this component should automatically follow"));
				MetaData->SetValue(NewProp_PlayerIndex, TEXT("Category"), TEXT("MotionController"));
				MetaData->SetValue(NewProp_PlayerIndex, TEXT("ModuleRelativePath"), TEXT("Public/GripMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_PlayerIndex, TEXT("ToolTip"), TEXT("Which player index this motion controller should automatically follow"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UGripMotionControllerComponent(Z_Construct_UClass_UGripMotionControllerComponent, &UGripMotionControllerComponent::StaticClass, TEXT("UGripMotionControllerComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UGripMotionControllerComponent);
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_CanHaveDoubleGrip()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanHaveDoubleGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableBoxComponent_eventCanHaveDoubleGrip_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableBoxComponent_eventCanHaveDoubleGrip_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableBoxComponent_eventCanHaveDoubleGrip_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableBoxComponent_eventCanHaveDoubleGrip_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Can have secondary grip"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_ClosestPrimarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestPrimarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableBoxComponent_eventClosestPrimarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableBoxComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableBoxComponent_eventClosestPrimarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableBoxComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableBoxComponent_eventClosestPrimarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableBoxComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest primary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_ClosestSecondarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestSecondarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableBoxComponent_eventClosestSecondarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableBoxComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableBoxComponent_eventClosestSecondarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableBoxComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableBoxComponent_eventClosestSecondarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableBoxComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest secondary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_DenyGripping()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DenyGripping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableBoxComponent_eventDenyGripping_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableBoxComponent_eventDenyGripping_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableBoxComponent_eventDenyGripping_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableBoxComponent_eventDenyGripping_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set up as deny instead of allow so that default allows for gripping"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_FreeGripType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FreeGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableBoxComponent_eventFreeGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableBoxComponent_eventFreeGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when not gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_GetInteractionSettings()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInteractionSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableBoxComponent_eventGetInteractionSettings_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableBoxComponent_eventGetInteractionSettings_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FBPInteractionSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get interactable settings"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_GripBreakDistance()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripBreakDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableBoxComponent_eventGripBreakDistance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableBoxComponent_eventGripBreakDistance_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What distance to break a grip at (only relevent with physics enabled grips"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_GripDamping()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableBoxComponent_eventGripDamping_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableBoxComponent_eventGripDamping_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip damping to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_GripLateUpdateSetting()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableBoxComponent_eventGripLateUpdateSetting_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableBoxComponent_eventGripLateUpdateSetting_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define the late update setting"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_GripMovementReplicationType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripMovementReplicationType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableBoxComponent_eventGripMovementReplicationType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableBoxComponent_eventGripMovementReplicationType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define which movement repliation setting to use"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_GripStiffness()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableBoxComponent_eventGripStiffness_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableBoxComponent_eventGripStiffness_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip stiffness to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_IsInteractible()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsInteractible"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableBoxComponent_eventIsInteractible_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableBoxComponent_eventIsInteractible_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableBoxComponent_eventIsInteractible_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableBoxComponent_eventIsInteractible_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the object is an interactable"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_ObjectType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(GrippableBoxComponent_eventObjectType_Parms));
			UProperty* NewProp_ObjectType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ObjectType, GrippableBoxComponent_eventObjectType_Parms), 0x0010000000000180);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Type of object, fill in with your own enum"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_SimulateOnDrop()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SimulateOnDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableBoxComponent_eventSimulateOnDrop_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableBoxComponent_eventSimulateOnDrop_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableBoxComponent_eventSimulateOnDrop_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableBoxComponent_eventSimulateOnDrop_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Should this object simulate on drop"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_SlotGripType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SlotGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableBoxComponent_eventSlotGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableBoxComponent_eventSlotGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableBoxComponent_TeleportBehavior()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableBoxComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TeleportBehavior"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableBoxComponent_eventTeleportBehavior_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableBoxComponent_eventTeleportBehavior_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("How an interfaced object behaves when teleporting"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UGrippableBoxComponent_NoRegister()
	{
		return UGrippableBoxComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UGrippableBoxComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UBoxComponent();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UGrippableBoxComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_CanHaveDoubleGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_ClosestPrimarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_ClosestSecondarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_DenyGripping());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_FreeGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_GetInteractionSettings());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_GripBreakDistance());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_GripDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_GripLateUpdateSetting());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_GripMovementReplicationType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_GripStiffness());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_IsInteractible());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_ObjectType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_SimulateOnDrop());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_SlotGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableBoxComponent_TeleportBehavior());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_VRGripInterfaceSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRGripInterfaceSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(VRGripInterfaceSettings, UGrippableBoxComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FBPInterfaceProperties());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_CanHaveDoubleGrip(), "CanHaveDoubleGrip"); // 3740894551
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_ClosestPrimarySlotInRange(), "ClosestPrimarySlotInRange"); // 2254190020
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_ClosestSecondarySlotInRange(), "ClosestSecondarySlotInRange"); // 2914422678
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_DenyGripping(), "DenyGripping"); // 1557742140
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_FreeGripType(), "FreeGripType"); // 2556961912
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_GetInteractionSettings(), "GetInteractionSettings"); // 3534452751
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_GripBreakDistance(), "GripBreakDistance"); // 382245061
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_GripDamping(), "GripDamping"); // 1173491914
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_GripLateUpdateSetting(), "GripLateUpdateSetting"); // 1453124308
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_GripMovementReplicationType(), "GripMovementReplicationType"); // 770978200
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_GripStiffness(), "GripStiffness"); // 1047819416
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_IsInteractible(), "IsInteractible"); // 3244900660
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_ObjectType(), "ObjectType"); // 1423131976
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_SimulateOnDrop(), "SimulateOnDrop"); // 3432943786
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_SlotGripType(), "SlotGripType"); // 570716365
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableBoxComponent_TeleportBehavior(), "TeleportBehavior"); // 52796579
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UVRGripInterface_NoRegister(), VTABLE_OFFSET(UGrippableBoxComponent, IVRGripInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("VRExpansionPlugin"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object LOD Lighting TextureStreaming Object LOD Lighting TextureStreaming Activation Components|Activation Trigger"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GrippableBoxComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("Category"), TEXT("VRGripInterface"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("ModuleRelativePath"), TEXT("Public/GrippableBoxComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UGrippableBoxComponent(Z_Construct_UClass_UGrippableBoxComponent, &UGrippableBoxComponent::StaticClass, TEXT("UGrippableBoxComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UGrippableBoxComponent);
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_CanHaveDoubleGrip()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanHaveDoubleGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableCapsuleComponent_eventCanHaveDoubleGrip_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableCapsuleComponent_eventCanHaveDoubleGrip_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableCapsuleComponent_eventCanHaveDoubleGrip_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableCapsuleComponent_eventCanHaveDoubleGrip_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Can have secondary grip"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_ClosestPrimarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestPrimarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableCapsuleComponent_eventClosestPrimarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableCapsuleComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableCapsuleComponent_eventClosestPrimarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableCapsuleComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableCapsuleComponent_eventClosestPrimarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableCapsuleComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest primary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_ClosestSecondarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestSecondarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableCapsuleComponent_eventClosestSecondarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableCapsuleComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableCapsuleComponent_eventClosestSecondarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableCapsuleComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableCapsuleComponent_eventClosestSecondarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableCapsuleComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest secondary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_DenyGripping()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DenyGripping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableCapsuleComponent_eventDenyGripping_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableCapsuleComponent_eventDenyGripping_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableCapsuleComponent_eventDenyGripping_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableCapsuleComponent_eventDenyGripping_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set up as deny instead of allow so that default allows for gripping"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_FreeGripType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FreeGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableCapsuleComponent_eventFreeGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableCapsuleComponent_eventFreeGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when not gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_GetInteractionSettings()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInteractionSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableCapsuleComponent_eventGetInteractionSettings_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableCapsuleComponent_eventGetInteractionSettings_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FBPInteractionSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get interactable settings"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_GripBreakDistance()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripBreakDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableCapsuleComponent_eventGripBreakDistance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableCapsuleComponent_eventGripBreakDistance_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What distance to break a grip at (only relevent with physics enabled grips"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_GripDamping()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableCapsuleComponent_eventGripDamping_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableCapsuleComponent_eventGripDamping_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip damping to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_GripLateUpdateSetting()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableCapsuleComponent_eventGripLateUpdateSetting_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableCapsuleComponent_eventGripLateUpdateSetting_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define the late update setting"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_GripMovementReplicationType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripMovementReplicationType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableCapsuleComponent_eventGripMovementReplicationType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableCapsuleComponent_eventGripMovementReplicationType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define which movement repliation setting to use"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_GripStiffness()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableCapsuleComponent_eventGripStiffness_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableCapsuleComponent_eventGripStiffness_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip stiffness to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_IsInteractible()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsInteractible"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableCapsuleComponent_eventIsInteractible_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableCapsuleComponent_eventIsInteractible_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableCapsuleComponent_eventIsInteractible_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableCapsuleComponent_eventIsInteractible_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the object is an interactable"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_ObjectType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(GrippableCapsuleComponent_eventObjectType_Parms));
			UProperty* NewProp_ObjectType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ObjectType, GrippableCapsuleComponent_eventObjectType_Parms), 0x0010000000000180);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Type of object, fill in with your own enum"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_SimulateOnDrop()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SimulateOnDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableCapsuleComponent_eventSimulateOnDrop_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableCapsuleComponent_eventSimulateOnDrop_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableCapsuleComponent_eventSimulateOnDrop_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableCapsuleComponent_eventSimulateOnDrop_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Should this object simulate on drop"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_SlotGripType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SlotGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableCapsuleComponent_eventSlotGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableCapsuleComponent_eventSlotGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableCapsuleComponent_TeleportBehavior()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableCapsuleComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TeleportBehavior"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableCapsuleComponent_eventTeleportBehavior_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableCapsuleComponent_eventTeleportBehavior_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("How an interfaced object behaves when teleporting"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UGrippableCapsuleComponent_NoRegister()
	{
		return UGrippableCapsuleComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UGrippableCapsuleComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UCapsuleComponent();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UGrippableCapsuleComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_CanHaveDoubleGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_ClosestPrimarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_ClosestSecondarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_DenyGripping());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_FreeGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_GetInteractionSettings());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_GripBreakDistance());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_GripDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_GripLateUpdateSetting());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_GripMovementReplicationType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_GripStiffness());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_IsInteractible());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_ObjectType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_SimulateOnDrop());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_SlotGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableCapsuleComponent_TeleportBehavior());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_VRGripInterfaceSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRGripInterfaceSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(VRGripInterfaceSettings, UGrippableCapsuleComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FBPInterfaceProperties());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_CanHaveDoubleGrip(), "CanHaveDoubleGrip"); // 2944809073
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_ClosestPrimarySlotInRange(), "ClosestPrimarySlotInRange"); // 1127417867
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_ClosestSecondarySlotInRange(), "ClosestSecondarySlotInRange"); // 1543451418
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_DenyGripping(), "DenyGripping"); // 775556875
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_FreeGripType(), "FreeGripType"); // 930761706
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_GetInteractionSettings(), "GetInteractionSettings"); // 493580842
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_GripBreakDistance(), "GripBreakDistance"); // 4194373244
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_GripDamping(), "GripDamping"); // 2573477528
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_GripLateUpdateSetting(), "GripLateUpdateSetting"); // 2768230941
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_GripMovementReplicationType(), "GripMovementReplicationType"); // 1229219686
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_GripStiffness(), "GripStiffness"); // 390545738
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_IsInteractible(), "IsInteractible"); // 2144826060
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_ObjectType(), "ObjectType"); // 202298996
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_SimulateOnDrop(), "SimulateOnDrop"); // 1008008189
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_SlotGripType(), "SlotGripType"); // 3404284530
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableCapsuleComponent_TeleportBehavior(), "TeleportBehavior"); // 2758235657
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UVRGripInterface_NoRegister(), VTABLE_OFFSET(UGrippableCapsuleComponent, IVRGripInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("VRExpansionPlugin"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object LOD Lighting TextureStreaming Object LOD Lighting TextureStreaming Activation Components|Activation Trigger"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GrippableCapsuleComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("Category"), TEXT("VRGripInterface"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("ModuleRelativePath"), TEXT("Public/GrippableCapsuleComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UGrippableCapsuleComponent(Z_Construct_UClass_UGrippableCapsuleComponent, &UGrippableCapsuleComponent::StaticClass, TEXT("UGrippableCapsuleComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UGrippableCapsuleComponent);
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_CanHaveDoubleGrip()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanHaveDoubleGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshActor_eventCanHaveDoubleGrip_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableSkeletalMeshActor_eventCanHaveDoubleGrip_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableSkeletalMeshActor_eventCanHaveDoubleGrip_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableSkeletalMeshActor_eventCanHaveDoubleGrip_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Can have secondary grip"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_ClosestPrimarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestPrimarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableSkeletalMeshActor_eventClosestPrimarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableSkeletalMeshActor_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableSkeletalMeshActor_eventClosestPrimarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableSkeletalMeshActor_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableSkeletalMeshActor_eventClosestPrimarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableSkeletalMeshActor_eventClosestPrimarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest primary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_ClosestSecondarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestSecondarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableSkeletalMeshActor_eventClosestSecondarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableSkeletalMeshActor_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableSkeletalMeshActor_eventClosestSecondarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableSkeletalMeshActor_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableSkeletalMeshActor_eventClosestSecondarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableSkeletalMeshActor_eventClosestSecondarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest secondary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_DenyGripping()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DenyGripping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshActor_eventDenyGripping_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableSkeletalMeshActor_eventDenyGripping_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableSkeletalMeshActor_eventDenyGripping_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableSkeletalMeshActor_eventDenyGripping_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set up as deny instead of allow so that default allows for gripping"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_FreeGripType()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FreeGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshActor_eventFreeGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshActor_eventFreeGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when not gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_GetInteractionSettings()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInteractionSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshActor_eventGetInteractionSettings_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshActor_eventGetInteractionSettings_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FBPInteractionSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get interactable settings"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripBreakDistance()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripBreakDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshActor_eventGripBreakDistance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshActor_eventGripBreakDistance_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What distance to break a grip at (only relevent with physics enabled grips"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripDamping()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshActor_eventGripDamping_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshActor_eventGripDamping_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip damping to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripLateUpdateSetting()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshActor_eventGripLateUpdateSetting_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshActor_eventGripLateUpdateSetting_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define the late update setting"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripMovementReplicationType()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripMovementReplicationType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshActor_eventGripMovementReplicationType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshActor_eventGripMovementReplicationType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define which movement repliation setting to use"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripStiffness()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshActor_eventGripStiffness_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshActor_eventGripStiffness_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip stiffness to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_IsInteractible()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsInteractible"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshActor_eventIsInteractible_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableSkeletalMeshActor_eventIsInteractible_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableSkeletalMeshActor_eventIsInteractible_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableSkeletalMeshActor_eventIsInteractible_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the object is an interactable"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_ObjectType()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(GrippableSkeletalMeshActor_eventObjectType_Parms));
			UProperty* NewProp_ObjectType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ObjectType, GrippableSkeletalMeshActor_eventObjectType_Parms), 0x0010000000000180);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Type of object, fill in with your own enum"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_SimulateOnDrop()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SimulateOnDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshActor_eventSimulateOnDrop_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableSkeletalMeshActor_eventSimulateOnDrop_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableSkeletalMeshActor_eventSimulateOnDrop_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableSkeletalMeshActor_eventSimulateOnDrop_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Should this object simulate on drop"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_SlotGripType()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SlotGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshActor_eventSlotGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshActor_eventSlotGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableSkeletalMeshActor_TeleportBehavior()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableSkeletalMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TeleportBehavior"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshActor_eventTeleportBehavior_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshActor_eventTeleportBehavior_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("How an interfaced object behaves when teleporting"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AGrippableSkeletalMeshActor_NoRegister()
	{
		return AGrippableSkeletalMeshActor::StaticClass();
	}
	UClass* Z_Construct_UClass_AGrippableSkeletalMeshActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ASkeletalMeshActor();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = AGrippableSkeletalMeshActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_CanHaveDoubleGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_ClosestPrimarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_ClosestSecondarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_DenyGripping());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_FreeGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_GetInteractionSettings());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripBreakDistance());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripLateUpdateSetting());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripMovementReplicationType());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripStiffness());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_IsInteractible());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_ObjectType());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_SimulateOnDrop());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_SlotGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableSkeletalMeshActor_TeleportBehavior());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_VRGripInterfaceSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRGripInterfaceSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(VRGripInterfaceSettings, AGrippableSkeletalMeshActor), 0x0010000000000005, Z_Construct_UScriptStruct_FBPInterfaceProperties());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_CanHaveDoubleGrip(), "CanHaveDoubleGrip"); // 1659308462
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_ClosestPrimarySlotInRange(), "ClosestPrimarySlotInRange"); // 3818058002
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_ClosestSecondarySlotInRange(), "ClosestSecondarySlotInRange"); // 3183772664
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_DenyGripping(), "DenyGripping"); // 3130975239
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_FreeGripType(), "FreeGripType"); // 1764716705
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_GetInteractionSettings(), "GetInteractionSettings"); // 3992350416
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripBreakDistance(), "GripBreakDistance"); // 33827061
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripDamping(), "GripDamping"); // 207609745
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripLateUpdateSetting(), "GripLateUpdateSetting"); // 3323059289
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripMovementReplicationType(), "GripMovementReplicationType"); // 33480555
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_GripStiffness(), "GripStiffness"); // 1096980526
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_IsInteractible(), "IsInteractible"); // 2960518422
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_ObjectType(), "ObjectType"); // 3539401743
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_SimulateOnDrop(), "SimulateOnDrop"); // 3299100345
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_SlotGripType(), "SlotGripType"); // 753791634
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableSkeletalMeshActor_TeleportBehavior(), "TeleportBehavior"); // 3218391415
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UVRGripInterface_NoRegister(), VTABLE_OFFSET(AGrippableSkeletalMeshActor, IVRGripInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("VRExpansionPlugin"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GrippableSkeletalMeshActor.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("Category"), TEXT("VRGripInterface"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshActor.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AGrippableSkeletalMeshActor(Z_Construct_UClass_AGrippableSkeletalMeshActor, &AGrippableSkeletalMeshActor::StaticClass, TEXT("AGrippableSkeletalMeshActor"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AGrippableSkeletalMeshActor);
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_CanHaveDoubleGrip()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanHaveDoubleGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventCanHaveDoubleGrip_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableSkeletalMeshComponent_eventCanHaveDoubleGrip_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableSkeletalMeshComponent_eventCanHaveDoubleGrip_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableSkeletalMeshComponent_eventCanHaveDoubleGrip_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Can have secondary grip"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_ClosestPrimarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestPrimarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventClosestPrimarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableSkeletalMeshComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableSkeletalMeshComponent_eventClosestPrimarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableSkeletalMeshComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableSkeletalMeshComponent_eventClosestPrimarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableSkeletalMeshComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest primary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_ClosestSecondarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestSecondarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventClosestSecondarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableSkeletalMeshComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableSkeletalMeshComponent_eventClosestSecondarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableSkeletalMeshComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableSkeletalMeshComponent_eventClosestSecondarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableSkeletalMeshComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest secondary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_DenyGripping()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DenyGripping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventDenyGripping_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableSkeletalMeshComponent_eventDenyGripping_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableSkeletalMeshComponent_eventDenyGripping_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableSkeletalMeshComponent_eventDenyGripping_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set up as deny instead of allow so that default allows for gripping"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_FreeGripType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FreeGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventFreeGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshComponent_eventFreeGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when not gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GetInteractionSettings()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInteractionSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventGetInteractionSettings_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshComponent_eventGetInteractionSettings_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FBPInteractionSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get interactable settings"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripBreakDistance()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripBreakDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventGripBreakDistance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshComponent_eventGripBreakDistance_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What distance to break a grip at (only relevent with physics enabled grips"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripDamping()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventGripDamping_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshComponent_eventGripDamping_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip damping to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripLateUpdateSetting()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventGripLateUpdateSetting_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshComponent_eventGripLateUpdateSetting_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define the late update setting"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripMovementReplicationType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripMovementReplicationType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventGripMovementReplicationType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshComponent_eventGripMovementReplicationType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define which movement repliation setting to use"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripStiffness()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventGripStiffness_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshComponent_eventGripStiffness_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip stiffness to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_IsInteractible()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsInteractible"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventIsInteractible_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableSkeletalMeshComponent_eventIsInteractible_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableSkeletalMeshComponent_eventIsInteractible_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableSkeletalMeshComponent_eventIsInteractible_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the object is an interactable"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_ObjectType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventObjectType_Parms));
			UProperty* NewProp_ObjectType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ObjectType, GrippableSkeletalMeshComponent_eventObjectType_Parms), 0x0010000000000180);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Type of object, fill in with your own enum"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_SimulateOnDrop()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SimulateOnDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventSimulateOnDrop_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableSkeletalMeshComponent_eventSimulateOnDrop_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableSkeletalMeshComponent_eventSimulateOnDrop_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableSkeletalMeshComponent_eventSimulateOnDrop_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Should this object simulate on drop"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_SlotGripType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SlotGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventSlotGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshComponent_eventSlotGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSkeletalMeshComponent_TeleportBehavior()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSkeletalMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TeleportBehavior"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSkeletalMeshComponent_eventTeleportBehavior_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSkeletalMeshComponent_eventTeleportBehavior_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("How an interfaced object behaves when teleporting"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UGrippableSkeletalMeshComponent_NoRegister()
	{
		return UGrippableSkeletalMeshComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UGrippableSkeletalMeshComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USkeletalMeshComponent();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UGrippableSkeletalMeshComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_CanHaveDoubleGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_ClosestPrimarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_ClosestSecondarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_DenyGripping());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_FreeGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GetInteractionSettings());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripBreakDistance());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripLateUpdateSetting());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripMovementReplicationType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripStiffness());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_IsInteractible());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_ObjectType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_SimulateOnDrop());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_SlotGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_TeleportBehavior());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_VRGripInterfaceSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRGripInterfaceSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(VRGripInterfaceSettings, UGrippableSkeletalMeshComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FBPInterfaceProperties());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_CanHaveDoubleGrip(), "CanHaveDoubleGrip"); // 748941135
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_ClosestPrimarySlotInRange(), "ClosestPrimarySlotInRange"); // 2988095837
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_ClosestSecondarySlotInRange(), "ClosestSecondarySlotInRange"); // 4075206626
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_DenyGripping(), "DenyGripping"); // 815170719
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_FreeGripType(), "FreeGripType"); // 4107570676
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GetInteractionSettings(), "GetInteractionSettings"); // 262024218
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripBreakDistance(), "GripBreakDistance"); // 3081185982
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripDamping(), "GripDamping"); // 3354385728
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripLateUpdateSetting(), "GripLateUpdateSetting"); // 2945075163
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripMovementReplicationType(), "GripMovementReplicationType"); // 1558116876
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_GripStiffness(), "GripStiffness"); // 3892108093
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_IsInteractible(), "IsInteractible"); // 58169413
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_ObjectType(), "ObjectType"); // 18087134
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_SimulateOnDrop(), "SimulateOnDrop"); // 829538058
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_SlotGripType(), "SlotGripType"); // 2633613770
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSkeletalMeshComponent_TeleportBehavior(), "TeleportBehavior"); // 2805802041
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UVRGripInterface_NoRegister(), VTABLE_OFFSET(UGrippableSkeletalMeshComponent, IVRGripInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("VRExpansionPlugin"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Object Mobility Trigger"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GrippableSkeletalMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("Category"), TEXT("VRGripInterface"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSkeletalMeshComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UGrippableSkeletalMeshComponent(Z_Construct_UClass_UGrippableSkeletalMeshComponent, &UGrippableSkeletalMeshComponent::StaticClass, TEXT("UGrippableSkeletalMeshComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UGrippableSkeletalMeshComponent);
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_CanHaveDoubleGrip()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanHaveDoubleGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSphereComponent_eventCanHaveDoubleGrip_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableSphereComponent_eventCanHaveDoubleGrip_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableSphereComponent_eventCanHaveDoubleGrip_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableSphereComponent_eventCanHaveDoubleGrip_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Can have secondary grip"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_ClosestPrimarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestPrimarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableSphereComponent_eventClosestPrimarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableSphereComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableSphereComponent_eventClosestPrimarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableSphereComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableSphereComponent_eventClosestPrimarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableSphereComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest primary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_ClosestSecondarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestSecondarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableSphereComponent_eventClosestSecondarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableSphereComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableSphereComponent_eventClosestSecondarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableSphereComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableSphereComponent_eventClosestSecondarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableSphereComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest secondary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_DenyGripping()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DenyGripping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSphereComponent_eventDenyGripping_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableSphereComponent_eventDenyGripping_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableSphereComponent_eventDenyGripping_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableSphereComponent_eventDenyGripping_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set up as deny instead of allow so that default allows for gripping"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_FreeGripType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FreeGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSphereComponent_eventFreeGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSphereComponent_eventFreeGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when not gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_GetInteractionSettings()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInteractionSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSphereComponent_eventGetInteractionSettings_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSphereComponent_eventGetInteractionSettings_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FBPInteractionSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get interactable settings"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_GripBreakDistance()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripBreakDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSphereComponent_eventGripBreakDistance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSphereComponent_eventGripBreakDistance_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What distance to break a grip at (only relevent with physics enabled grips"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_GripDamping()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSphereComponent_eventGripDamping_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSphereComponent_eventGripDamping_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip damping to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_GripLateUpdateSetting()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSphereComponent_eventGripLateUpdateSetting_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSphereComponent_eventGripLateUpdateSetting_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define the late update setting"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_GripMovementReplicationType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripMovementReplicationType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSphereComponent_eventGripMovementReplicationType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSphereComponent_eventGripMovementReplicationType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define which movement repliation setting to use"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_GripStiffness()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSphereComponent_eventGripStiffness_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSphereComponent_eventGripStiffness_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip stiffness to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_IsInteractible()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsInteractible"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSphereComponent_eventIsInteractible_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableSphereComponent_eventIsInteractible_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableSphereComponent_eventIsInteractible_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableSphereComponent_eventIsInteractible_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the object is an interactable"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_ObjectType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(GrippableSphereComponent_eventObjectType_Parms));
			UProperty* NewProp_ObjectType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ObjectType, GrippableSphereComponent_eventObjectType_Parms), 0x0010000000000180);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Type of object, fill in with your own enum"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_SimulateOnDrop()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SimulateOnDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSphereComponent_eventSimulateOnDrop_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableSphereComponent_eventSimulateOnDrop_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableSphereComponent_eventSimulateOnDrop_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableSphereComponent_eventSimulateOnDrop_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Should this object simulate on drop"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_SlotGripType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SlotGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSphereComponent_eventSlotGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSphereComponent_eventSlotGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableSphereComponent_TeleportBehavior()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableSphereComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TeleportBehavior"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableSphereComponent_eventTeleportBehavior_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableSphereComponent_eventTeleportBehavior_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("How an interfaced object behaves when teleporting"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UGrippableSphereComponent_NoRegister()
	{
		return UGrippableSphereComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UGrippableSphereComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USphereComponent();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UGrippableSphereComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_CanHaveDoubleGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_ClosestPrimarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_ClosestSecondarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_DenyGripping());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_FreeGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_GetInteractionSettings());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_GripBreakDistance());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_GripDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_GripLateUpdateSetting());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_GripMovementReplicationType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_GripStiffness());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_IsInteractible());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_ObjectType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_SimulateOnDrop());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_SlotGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableSphereComponent_TeleportBehavior());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_VRGripInterfaceSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRGripInterfaceSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(VRGripInterfaceSettings, UGrippableSphereComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FBPInterfaceProperties());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_CanHaveDoubleGrip(), "CanHaveDoubleGrip"); // 680013312
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_ClosestPrimarySlotInRange(), "ClosestPrimarySlotInRange"); // 1070451835
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_ClosestSecondarySlotInRange(), "ClosestSecondarySlotInRange"); // 1315722030
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_DenyGripping(), "DenyGripping"); // 502356829
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_FreeGripType(), "FreeGripType"); // 2510918330
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_GetInteractionSettings(), "GetInteractionSettings"); // 1853475045
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_GripBreakDistance(), "GripBreakDistance"); // 2011590053
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_GripDamping(), "GripDamping"); // 2862175817
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_GripLateUpdateSetting(), "GripLateUpdateSetting"); // 57670133
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_GripMovementReplicationType(), "GripMovementReplicationType"); // 1403611730
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_GripStiffness(), "GripStiffness"); // 1271847469
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_IsInteractible(), "IsInteractible"); // 2531558491
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_ObjectType(), "ObjectType"); // 2117196435
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_SimulateOnDrop(), "SimulateOnDrop"); // 316057976
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_SlotGripType(), "SlotGripType"); // 3877946008
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableSphereComponent_TeleportBehavior(), "TeleportBehavior"); // 3790300887
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UVRGripInterface_NoRegister(), VTABLE_OFFSET(UGrippableSphereComponent, IVRGripInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("VRExpansionPlugin"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object LOD Lighting TextureStreaming Object LOD Lighting TextureStreaming Activation Components|Activation Trigger"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GrippableSphereComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("Category"), TEXT("VRGripInterface"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("ModuleRelativePath"), TEXT("Public/GrippableSphereComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UGrippableSphereComponent(Z_Construct_UClass_UGrippableSphereComponent, &UGrippableSphereComponent::StaticClass, TEXT("UGrippableSphereComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UGrippableSphereComponent);
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_CanHaveDoubleGrip()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanHaveDoubleGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshActor_eventCanHaveDoubleGrip_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableStaticMeshActor_eventCanHaveDoubleGrip_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableStaticMeshActor_eventCanHaveDoubleGrip_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableStaticMeshActor_eventCanHaveDoubleGrip_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Can have secondary grip"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_ClosestPrimarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestPrimarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableStaticMeshActor_eventClosestPrimarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableStaticMeshActor_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableStaticMeshActor_eventClosestPrimarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableStaticMeshActor_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableStaticMeshActor_eventClosestPrimarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableStaticMeshActor_eventClosestPrimarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest primary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_ClosestSecondarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestSecondarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableStaticMeshActor_eventClosestSecondarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableStaticMeshActor_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableStaticMeshActor_eventClosestSecondarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableStaticMeshActor_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableStaticMeshActor_eventClosestSecondarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableStaticMeshActor_eventClosestSecondarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest secondary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_DenyGripping()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DenyGripping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshActor_eventDenyGripping_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableStaticMeshActor_eventDenyGripping_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableStaticMeshActor_eventDenyGripping_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableStaticMeshActor_eventDenyGripping_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set up as deny instead of allow so that default allows for gripping"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_FreeGripType()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FreeGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshActor_eventFreeGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshActor_eventFreeGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when not gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_GetInteractionSettings()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInteractionSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshActor_eventGetInteractionSettings_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshActor_eventGetInteractionSettings_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FBPInteractionSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get interactable settings"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_GripBreakDistance()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripBreakDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshActor_eventGripBreakDistance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshActor_eventGripBreakDistance_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What distance to break a grip at (only relevent with physics enabled grips"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_GripDamping()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshActor_eventGripDamping_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshActor_eventGripDamping_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip damping to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_GripLateUpdateSetting()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshActor_eventGripLateUpdateSetting_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshActor_eventGripLateUpdateSetting_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define the late update setting"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_GripMovementReplicationType()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripMovementReplicationType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshActor_eventGripMovementReplicationType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshActor_eventGripMovementReplicationType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define which movement repliation setting to use"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_GripStiffness()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshActor_eventGripStiffness_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshActor_eventGripStiffness_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip stiffness to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_IsInteractible()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsInteractible"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshActor_eventIsInteractible_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableStaticMeshActor_eventIsInteractible_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableStaticMeshActor_eventIsInteractible_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableStaticMeshActor_eventIsInteractible_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the object is an interactable"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_ObjectType()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(GrippableStaticMeshActor_eventObjectType_Parms));
			UProperty* NewProp_ObjectType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ObjectType, GrippableStaticMeshActor_eventObjectType_Parms), 0x0010000000000180);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Type of object, fill in with your own enum"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_SimulateOnDrop()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SimulateOnDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshActor_eventSimulateOnDrop_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableStaticMeshActor_eventSimulateOnDrop_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableStaticMeshActor_eventSimulateOnDrop_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableStaticMeshActor_eventSimulateOnDrop_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Should this object simulate on drop"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_SlotGripType()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SlotGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshActor_eventSlotGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshActor_eventSlotGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AGrippableStaticMeshActor_TeleportBehavior()
	{
		UObject* Outer=Z_Construct_UClass_AGrippableStaticMeshActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TeleportBehavior"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshActor_eventTeleportBehavior_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshActor_eventTeleportBehavior_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("How an interfaced object behaves when teleporting"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AGrippableStaticMeshActor_NoRegister()
	{
		return AGrippableStaticMeshActor::StaticClass();
	}
	UClass* Z_Construct_UClass_AGrippableStaticMeshActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AStaticMeshActor();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = AGrippableStaticMeshActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_CanHaveDoubleGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_ClosestPrimarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_ClosestSecondarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_DenyGripping());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_FreeGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_GetInteractionSettings());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_GripBreakDistance());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_GripDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_GripLateUpdateSetting());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_GripMovementReplicationType());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_GripStiffness());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_IsInteractible());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_ObjectType());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_SimulateOnDrop());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_SlotGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_AGrippableStaticMeshActor_TeleportBehavior());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_VRGripInterfaceSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRGripInterfaceSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(VRGripInterfaceSettings, AGrippableStaticMeshActor), 0x0010000000000005, Z_Construct_UScriptStruct_FBPInterfaceProperties());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_CanHaveDoubleGrip(), "CanHaveDoubleGrip"); // 89839533
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_ClosestPrimarySlotInRange(), "ClosestPrimarySlotInRange"); // 4051350314
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_ClosestSecondarySlotInRange(), "ClosestSecondarySlotInRange"); // 431153299
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_DenyGripping(), "DenyGripping"); // 3281234776
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_FreeGripType(), "FreeGripType"); // 2865880090
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_GetInteractionSettings(), "GetInteractionSettings"); // 691052434
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_GripBreakDistance(), "GripBreakDistance"); // 595099532
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_GripDamping(), "GripDamping"); // 435097795
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_GripLateUpdateSetting(), "GripLateUpdateSetting"); // 1737043189
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_GripMovementReplicationType(), "GripMovementReplicationType"); // 2286373632
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_GripStiffness(), "GripStiffness"); // 405411578
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_IsInteractible(), "IsInteractible"); // 939536062
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_ObjectType(), "ObjectType"); // 2892652917
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_SimulateOnDrop(), "SimulateOnDrop"); // 1964938005
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_SlotGripType(), "SlotGripType"); // 814727898
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AGrippableStaticMeshActor_TeleportBehavior(), "TeleportBehavior"); // 1333226270
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UVRGripInterface_NoRegister(), VTABLE_OFFSET(AGrippableStaticMeshActor, IVRGripInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("VRExpansionPlugin"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Input"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GrippableStaticMeshActor.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ShowCategories"), TEXT("Input|MouseInput Input|TouchInput"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("Category"), TEXT("VRGripInterface"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshActor.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AGrippableStaticMeshActor(Z_Construct_UClass_AGrippableStaticMeshActor, &AGrippableStaticMeshActor::StaticClass, TEXT("AGrippableStaticMeshActor"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AGrippableStaticMeshActor);
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_CanHaveDoubleGrip()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CanHaveDoubleGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshComponent_eventCanHaveDoubleGrip_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableStaticMeshComponent_eventCanHaveDoubleGrip_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableStaticMeshComponent_eventCanHaveDoubleGrip_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableStaticMeshComponent_eventCanHaveDoubleGrip_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Can have secondary grip"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_ClosestPrimarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestPrimarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableStaticMeshComponent_eventClosestPrimarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableStaticMeshComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableStaticMeshComponent_eventClosestPrimarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableStaticMeshComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableStaticMeshComponent_eventClosestPrimarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableStaticMeshComponent_eventClosestPrimarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest primary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_ClosestSecondarySlotInRange()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestSecondarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0CC20C00, 65535, sizeof(GrippableStaticMeshComponent_eventClosestSecondarySlotInRange_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, GrippableStaticMeshComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, GrippableStaticMeshComponent_eventClosestSecondarySlotInRange_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, GrippableStaticMeshComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, GrippableStaticMeshComponent_eventClosestSecondarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, GrippableStaticMeshComponent_eventClosestSecondarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest secondary slot in range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_DenyGripping()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DenyGripping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshComponent_eventDenyGripping_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableStaticMeshComponent_eventDenyGripping_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableStaticMeshComponent_eventDenyGripping_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableStaticMeshComponent_eventDenyGripping_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set up as deny instead of allow so that default allows for gripping"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_FreeGripType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FreeGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshComponent_eventFreeGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshComponent_eventFreeGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when not gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_GetInteractionSettings()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInteractionSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshComponent_eventGetInteractionSettings_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshComponent_eventGetInteractionSettings_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FBPInteractionSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get interactable settings"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_GripBreakDistance()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripBreakDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshComponent_eventGripBreakDistance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshComponent_eventGripBreakDistance_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What distance to break a grip at (only relevent with physics enabled grips"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_GripDamping()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshComponent_eventGripDamping_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshComponent_eventGripDamping_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip damping to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_GripLateUpdateSetting()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshComponent_eventGripLateUpdateSetting_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshComponent_eventGripLateUpdateSetting_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define the late update setting"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_GripMovementReplicationType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripMovementReplicationType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshComponent_eventGripMovementReplicationType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshComponent_eventGripMovementReplicationType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define which movement repliation setting to use"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_GripStiffness()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshComponent_eventGripStiffness_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshComponent_eventGripStiffness_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip stiffness to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_IsInteractible()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsInteractible"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshComponent_eventIsInteractible_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableStaticMeshComponent_eventIsInteractible_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableStaticMeshComponent_eventIsInteractible_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableStaticMeshComponent_eventIsInteractible_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the object is an interactable"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_ObjectType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(GrippableStaticMeshComponent_eventObjectType_Parms));
			UProperty* NewProp_ObjectType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ObjectType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ObjectType, GrippableStaticMeshComponent_eventObjectType_Parms), 0x0010000000000180);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Type of object, fill in with your own enum"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_SimulateOnDrop()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SimulateOnDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshComponent_eventSimulateOnDrop_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, GrippableStaticMeshComponent_eventSimulateOnDrop_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, GrippableStaticMeshComponent_eventSimulateOnDrop_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, GrippableStaticMeshComponent_eventSimulateOnDrop_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Should this object simulate on drop"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_SlotGripType()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SlotGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshComponent_eventSlotGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshComponent_eventSlotGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UGrippableStaticMeshComponent_TeleportBehavior()
	{
		UObject* Outer=Z_Construct_UClass_UGrippableStaticMeshComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TeleportBehavior"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(GrippableStaticMeshComponent_eventTeleportBehavior_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, GrippableStaticMeshComponent_eventTeleportBehavior_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("How an interfaced object behaves when teleporting"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UGrippableStaticMeshComponent_NoRegister()
	{
		return UGrippableStaticMeshComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UGrippableStaticMeshComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UStaticMeshComponent();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UGrippableStaticMeshComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_CanHaveDoubleGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_ClosestPrimarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_ClosestSecondarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_DenyGripping());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_FreeGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_GetInteractionSettings());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_GripBreakDistance());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_GripDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_GripLateUpdateSetting());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_GripMovementReplicationType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_GripStiffness());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_IsInteractible());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_ObjectType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_SimulateOnDrop());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_SlotGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UGrippableStaticMeshComponent_TeleportBehavior());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_VRGripInterfaceSettings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRGripInterfaceSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(VRGripInterfaceSettings, UGrippableStaticMeshComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FBPInterfaceProperties());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_CanHaveDoubleGrip(), "CanHaveDoubleGrip"); // 2580006768
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_ClosestPrimarySlotInRange(), "ClosestPrimarySlotInRange"); // 1819990219
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_ClosestSecondarySlotInRange(), "ClosestSecondarySlotInRange"); // 3381661740
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_DenyGripping(), "DenyGripping"); // 2795904747
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_FreeGripType(), "FreeGripType"); // 2188520216
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_GetInteractionSettings(), "GetInteractionSettings"); // 2076307061
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_GripBreakDistance(), "GripBreakDistance"); // 3654207547
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_GripDamping(), "GripDamping"); // 3550010510
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_GripLateUpdateSetting(), "GripLateUpdateSetting"); // 2891711928
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_GripMovementReplicationType(), "GripMovementReplicationType"); // 97639566
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_GripStiffness(), "GripStiffness"); // 271963671
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_IsInteractible(), "IsInteractible"); // 571537698
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_ObjectType(), "ObjectType"); // 2070474638
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_SimulateOnDrop(), "SimulateOnDrop"); // 441434460
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_SlotGripType(), "SlotGripType"); // 2343218597
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UGrippableStaticMeshComponent_TeleportBehavior(), "TeleportBehavior"); // 2874177932
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UVRGripInterface_NoRegister(), VTABLE_OFFSET(UGrippableStaticMeshComponent, IVRGripInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("VRExpansionPlugin"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Activation Components|Activation Trigger"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("GrippableStaticMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("Category"), TEXT("VRGripInterface"));
				MetaData->SetValue(NewProp_VRGripInterfaceSettings, TEXT("ModuleRelativePath"), TEXT("Public/GrippableStaticMeshComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UGrippableStaticMeshComponent(Z_Construct_UClass_UGrippableStaticMeshComponent, &UGrippableStaticMeshComponent::StaticClass, TEXT("UGrippableStaticMeshComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UGrippableStaticMeshComponent);
	UClass* Z_Construct_UClass_UParentRelativeAttachmentComponent_NoRegister()
	{
		return UParentRelativeAttachmentComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UParentRelativeAttachmentComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UParentRelativeAttachmentComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_YawTolerance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("YawTolerance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(YawTolerance, UParentRelativeAttachmentComponent), 0x0010000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("VRExpansionLibrary"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Trigger PhysicsVolume"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("ParentRelativeAttachmentComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/ParentRelativeAttachmentComponent.h"));
				MetaData->SetValue(NewProp_YawTolerance, TEXT("Category"), TEXT("VRExpansionLibrary"));
				MetaData->SetValue(NewProp_YawTolerance, TEXT("ClampMin"), TEXT("0"));
				MetaData->SetValue(NewProp_YawTolerance, TEXT("ModuleRelativePath"), TEXT("Public/ParentRelativeAttachmentComponent.h"));
				MetaData->SetValue(NewProp_YawTolerance, TEXT("UIMin"), TEXT("0"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UParentRelativeAttachmentComponent(Z_Construct_UClass_UParentRelativeAttachmentComponent, &UParentRelativeAttachmentComponent::StaticClass, TEXT("UParentRelativeAttachmentComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UParentRelativeAttachmentComponent);
	UFunction* Z_Construct_UFunction_UReplicatedVRCameraComponent_GetCameraView()
	{
		struct ReplicatedVRCameraComponent_eventGetCameraView_Parms
		{
			float DeltaTime;
			FMinimalViewInfo DesiredView;
		};
		UObject* Outer=Z_Construct_UClass_UReplicatedVRCameraComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetCameraView"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420400, 65535, sizeof(ReplicatedVRCameraComponent_eventGetCameraView_Parms));
			UProperty* NewProp_DesiredView = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DesiredView"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(DesiredView, ReplicatedVRCameraComponent_eventGetCameraView_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FMinimalViewInfo());
			UProperty* NewProp_DeltaTime = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeltaTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DeltaTime, ReplicatedVRCameraComponent_eventGetCameraView_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Camera"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/ReplicatedVRCameraComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UReplicatedVRCameraComponent_OnRep_ReplicatedTransform()
	{
		UObject* Outer=Z_Construct_UClass_UReplicatedVRCameraComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnRep_ReplicatedTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/ReplicatedVRCameraComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UReplicatedVRCameraComponent_Server_SendTransform()
	{
		UObject* Outer=Z_Construct_UClass_UReplicatedVRCameraComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Server_SendTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220C40, 65535, sizeof(ReplicatedVRCameraComponent_eventServer_SendTransform_Parms));
			UProperty* NewProp_NewTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(NewTransform, ReplicatedVRCameraComponent_eventServer_SendTransform_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FBPVRComponentPosRep());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/ReplicatedVRCameraComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("I'm sending it unreliable because it is being resent pretty often"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UReplicatedVRCameraComponent_NoRegister()
	{
		return UReplicatedVRCameraComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UReplicatedVRCameraComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UCameraComponent();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UReplicatedVRCameraComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UReplicatedVRCameraComponent_GetCameraView());
				OuterClass->LinkChild(Z_Construct_UFunction_UReplicatedVRCameraComponent_OnRep_ReplicatedTransform());
				OuterClass->LinkChild(Z_Construct_UFunction_UReplicatedVRCameraComponent_Server_SendTransform());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_NetUpdateRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NetUpdateRate"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(NetUpdateRate, UReplicatedVRCameraComponent), 0x0010000000000025);
				UProperty* NewProp_ReplicatedTransform = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ReplicatedTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReplicatedTransform, UReplicatedVRCameraComponent), 0x0010000100000034, Z_Construct_UScriptStruct_FBPVRComponentPosRep());
				NewProp_ReplicatedTransform->RepNotifyFunc = FName(TEXT("OnRep_ReplicatedTransform"));
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAutoSetLockToHmd, UReplicatedVRCameraComponent, uint8);
				UProperty* NewProp_bAutoSetLockToHmd = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAutoSetLockToHmd"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAutoSetLockToHmd, UReplicatedVRCameraComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bAutoSetLockToHmd, UReplicatedVRCameraComponent), sizeof(uint8), false);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UReplicatedVRCameraComponent_GetCameraView(), "GetCameraView"); // 2411523815
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UReplicatedVRCameraComponent_OnRep_ReplicatedTransform(), "OnRep_ReplicatedTransform"); // 2364180053
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UReplicatedVRCameraComponent_Server_SendTransform(), "Server_SendTransform"); // 4268126170
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("VRExpansionLibrary"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Mobility Rendering LOD Trigger PhysicsVolume"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("ReplicatedVRCameraComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/ReplicatedVRCameraComponent.h"));
				MetaData->SetValue(NewProp_NetUpdateRate, TEXT("Category"), TEXT("VRExpansionLibrary"));
				MetaData->SetValue(NewProp_NetUpdateRate, TEXT("ModuleRelativePath"), TEXT("Public/ReplicatedVRCameraComponent.h"));
				MetaData->SetValue(NewProp_NetUpdateRate, TEXT("ToolTip"), TEXT("Rate to update the position to the server, 100htz is default (same as replication rate, should also hit every tick)."));
				MetaData->SetValue(NewProp_ReplicatedTransform, TEXT("Category"), TEXT("VRExpansionLibrary"));
				MetaData->SetValue(NewProp_ReplicatedTransform, TEXT("ModuleRelativePath"), TEXT("Public/ReplicatedVRCameraComponent.h"));
				MetaData->SetValue(NewProp_bAutoSetLockToHmd, TEXT("Category"), TEXT("VRExpansionLibrary"));
				MetaData->SetValue(NewProp_bAutoSetLockToHmd, TEXT("ModuleRelativePath"), TEXT("Public/ReplicatedVRCameraComponent.h"));
				MetaData->SetValue(NewProp_bAutoSetLockToHmd, TEXT("ToolTip"), TEXT("Sets lock to hmd automatically based on if the camera is currently locally controlled or not"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UReplicatedVRCameraComponent(Z_Construct_UClass_UReplicatedVRCameraComponent, &UReplicatedVRCameraComponent::StaticClass, TEXT("UReplicatedVRCameraComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UReplicatedVRCameraComponent);
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EVRControllerProperty_String()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EVRControllerProperty_String_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EVRControllerProperty_String"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EVRControllerProperty_String_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EVRControllerProperty_String"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_AttachedDeviceId_String")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_AttachedDeviceId_MAX")), 1));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("EVRControllerProperty_String");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EVRControllerProperty_String_CRC() { return 3848693739U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Float()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Float_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EVRDeviceProperty_Float"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Float_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EVRDeviceProperty_Float"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_DeviceBatteryPercentage_Float")), 12));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_DeviceBatteryPercentage_MAX")), 13));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("EVRDeviceProperty_Float");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Float_CRC() { return 2998107657U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Bool()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Bool_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EVRDeviceProperty_Bool"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Bool_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EVRDeviceProperty_Bool"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_WillDriftInYaw_Bool")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_DeviceIsWireless_Bool")), 10));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_DeviceIsCharging_Bool")), 11));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_Firmware_UpdateAvailable_Bool")), 14));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_Firmware_ManualUpdate_Bool")), 15));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_BlockServerShutdown_Bool")), 23));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_CanUnifyCoordinateSystemWithHmd_Bool")), 24));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_ContainsProximitySensor_Bool")), 25));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_DeviceProvidesBatteryStatus_Bool")), 26));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Prop_MAX")), 27));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("EVRDeviceProperty_Bool");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Bool_CRC() { return 1633996441U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_String()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_String_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EVRDeviceProperty_String"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_String_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EVRDeviceProperty_String"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRDeviceProperty_String::Prop_TrackingSystemName_String")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRDeviceProperty_String::Prop_ModelNumber_String")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRDeviceProperty_String::Prop_SerialNumber_String")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRDeviceProperty_String::Prop_RenderModelName_String")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRDeviceProperty_String::Prop_ManufacturerName_String")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRDeviceProperty_String::Prop_TrackingFirmwareVersion_String")), 6));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRDeviceProperty_String::Prop_HardwareRevision_String")), 7));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRDeviceProperty_String::Prop_AllWirelessDongleDescriptions_String")), 8));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRDeviceProperty_String::Prop_ConnectedWirelessDongle_String")), 9));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRDeviceProperty_String::Prop_Firmware_ManualUpdateURL_String")), 16));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EVRDeviceProperty_String::Prop_MAX")), 17));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
			ReturnEnum->CppType = TEXT("EVRDeviceProperty_String");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_String_CRC() { return 3435772494U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EBPWorldType()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EBPWorldType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EBPWorldType"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EBPWorldType_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EBPWorldType"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPWorldType::wNone")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPWorldType::wGame")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPWorldType::wEditor")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPWorldType::wPIE")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPWorldType::wPreview")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPWorldType::wInactive")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EBPWorldType::EBPWorldType_MAX")), 6));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
			ReturnEnum->CppType = TEXT("EBPWorldType");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnEnum, TEXT("wEditor.ToolTip"), TEXT("The game world"));
			MetaData->SetValue(ReturnEnum, TEXT("wGame.ToolTip"), TEXT("An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels"));
			MetaData->SetValue(ReturnEnum, TEXT("wInactive.ToolTip"), TEXT("A preview world for an editor tool"));
			MetaData->SetValue(ReturnEnum, TEXT("wPIE.ToolTip"), TEXT("A world being edited in the editor"));
			MetaData->SetValue(ReturnEnum, TEXT("wPreview.ToolTip"), TEXT("A Play In Editor world"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EBPWorldType_CRC() { return 1850367976U; }
	UEnum* Z_Construct_UEnum_VRExpansionPlugin_EAsyncBlueprintResultSwitch()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_VRExpansionPlugin();
		extern uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EAsyncBlueprintResultSwitch_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAsyncBlueprintResultSwitch"), 0, Get_Z_Construct_UEnum_VRExpansionPlugin_EAsyncBlueprintResultSwitch_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAsyncBlueprintResultSwitch"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAsyncBlueprintResultSwitch::OnSuccess")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAsyncBlueprintResultSwitch::AsyncLoading")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAsyncBlueprintResultSwitch::OnFailure")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EAsyncBlueprintResultSwitch::EAsyncBlueprintResultSwitch_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("EAsyncBlueprintResultSwitch::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("AsyncLoading.ToolTip"), TEXT("On still loading async"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnEnum, TEXT("OnFailure.ToolTip"), TEXT("On Failure"));
			MetaData->SetValue(ReturnEnum, TEXT("OnSuccess.ToolTip"), TEXT("On Success"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("This will make using the load model as async easier to understand"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_VRExpansionPlugin_EAsyncBlueprintResultSwitch_CRC() { return 2235401085U; }
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_CloseVRHandles()
	{
		struct VRExpansionFunctionLibrary_eventCloseVRHandles_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CloseVRHandles"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(VRExpansionFunctionLibrary_eventCloseVRHandles_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRExpansionFunctionLibrary_eventCloseVRHandles_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRExpansionFunctionLibrary_eventCloseVRHandles_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRExpansionFunctionLibrary_eventCloseVRHandles_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRExpansionFunctions|SteamVR"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Closes the handles for the library"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetGripSlotInRangeByTypeName()
	{
		struct VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Parms
		{
			FName SlotType;
			AActor* Actor;
			FVector WorldLocation;
			float MaxRange;
			bool bHadSlotInRange;
			FTransform SlotWorldTransform;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetGripSlotInRangeByTypeName"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Parms), sizeof(bool), true);
			UProperty* NewProp_MaxRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MaxRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxRange, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Parms), 0x0010000000000080);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Actor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Actor"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Actor, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_SlotType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotType"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(SlotType, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetGripSlotInRangeByTypeName"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets if an actors root component contains a grip slot within range"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetGripSlotInRangeByTypeName_Component()
	{
		struct VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Component_Parms
		{
			FName SlotType;
			UPrimitiveComponent* Component;
			FVector WorldLocation;
			float MaxRange;
			bool bHadSlotInRange;
			FTransform SlotWorldTransform;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetGripSlotInRangeByTypeName_Component"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Component_Parms));
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Component_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Component_Parms, bool);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Component_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Component_Parms), sizeof(bool), true);
			UProperty* NewProp_MaxRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("MaxRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxRange, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Component_Parms), 0x0010000000000080);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Component_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Component = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Component"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Component, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Component_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_SlotType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotType"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(SlotType, VRExpansionFunctionLibrary_eventGetGripSlotInRangeByTypeName_Component_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetGripSlotInRangeByTypeName_Component"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets if an actors root component contains a grip slot within range"));
			MetaData->SetValue(NewProp_Component, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetHMDPureYaw()
	{
		struct VRExpansionFunctionLibrary_eventGetHMDPureYaw_Parms
		{
			FRotator HMDRotation;
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetHMDPureYaw"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14822401, 65535, sizeof(VRExpansionFunctionLibrary_eventGetHMDPureYaw_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRExpansionFunctionLibrary_eventGetHMDPureYaw_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_HMDRotation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HMDRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(HMDRotation, VRExpansionFunctionLibrary_eventGetHMDPureYaw_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRExpansionFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetHMDPureYaw"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the unwound yaw of the HMD"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetHMDType()
	{
		struct VRExpansionFunctionLibrary_eventGetHMDType_Parms
		{
			TEnumAsByte<EBPHMDDeviceType> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetHMDType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14022401, 65535, sizeof(VRExpansionFunctionLibrary_eventGetHMDType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, VRExpansionFunctionLibrary_eventGetHMDType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EBPHMDDeviceType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRExpansionFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetHMDType"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets whether an HMD device is connected"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetIsActorMovable()
	{
		struct VRExpansionFunctionLibrary_eventGetIsActorMovable_Parms
		{
			AActor* ActorToCheck;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetIsActorMovable"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14022401, 65535, sizeof(VRExpansionFunctionLibrary_eventGetIsActorMovable_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRExpansionFunctionLibrary_eventGetIsActorMovable_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRExpansionFunctionLibrary_eventGetIsActorMovable_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRExpansionFunctionLibrary_eventGetIsActorMovable_Parms), sizeof(bool), true);
			UProperty* NewProp_ActorToCheck = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ActorToCheck"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ActorToCheck, VRExpansionFunctionLibrary_eventGetIsActorMovable_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRExpansionFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetIsActorMovable"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets whether an HMD device is connected"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetIsHMDConnected()
	{
		struct VRExpansionFunctionLibrary_eventGetIsHMDConnected_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetIsHMDConnected"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14022401, 65535, sizeof(VRExpansionFunctionLibrary_eventGetIsHMDConnected_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRExpansionFunctionLibrary_eventGetIsHMDConnected_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRExpansionFunctionLibrary_eventGetIsHMDConnected_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRExpansionFunctionLibrary_eventGetIsHMDConnected_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRExpansionFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetIsHMDConnected"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets whether an HMD device is connected"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRControllerPropertyString()
	{
		struct VRExpansionFunctionLibrary_eventGetVRControllerPropertyString_Parms
		{
			TEnumAsByte<EVRControllerProperty_String> PropertyToRetrieve;
			int32 DeviceID;
			FString StringValue;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRControllerPropertyString"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(VRExpansionFunctionLibrary_eventGetVRControllerPropertyString_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRExpansionFunctionLibrary_eventGetVRControllerPropertyString_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRExpansionFunctionLibrary_eventGetVRControllerPropertyString_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRExpansionFunctionLibrary_eventGetVRControllerPropertyString_Parms), sizeof(bool), true);
			UProperty* NewProp_StringValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StringValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStrProperty(CPP_PROPERTY_BASE(StringValue, VRExpansionFunctionLibrary_eventGetVRControllerPropertyString_Parms), 0x0010000000000180);
			UProperty* NewProp_DeviceID = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeviceID"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(DeviceID, VRExpansionFunctionLibrary_eventGetVRControllerPropertyString_Parms), 0x0010000000000080);
			UProperty* NewProp_PropertyToRetrieve = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PropertyToRetrieve"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(PropertyToRetrieve, VRExpansionFunctionLibrary_eventGetVRControllerPropertyString_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EVRControllerProperty_String());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRExpansionFunctions|SteamVR"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetVRControllerPropertyString"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets a String controller property"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDeviceModelAndTexture()
	{
		struct VRExpansionFunctionLibrary_eventGetVRDeviceModelAndTexture_Parms
		{
			UObject* WorldContextObject;
			EBPSteamVRTrackedDeviceType DeviceType;
			TArray<UProceduralMeshComponent*> ProceduralMeshComponentsToFill;
			bool bCreateCollision;
			TEnumAsByte<EAsyncBlueprintResultSwitch::Type> Result;
			UTexture2D* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRDeviceModelAndTexture"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(VRExpansionFunctionLibrary_eventGetVRDeviceModelAndTexture_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, VRExpansionFunctionLibrary_eventGetVRDeviceModelAndTexture_Parms), 0x0010000000000580, Z_Construct_UClass_UTexture2D_NoRegister());
			UProperty* NewProp_Result = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Result"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Result, VRExpansionFunctionLibrary_eventGetVRDeviceModelAndTexture_Parms), 0x0010000000000180, Z_Construct_UEnum_VRExpansionPlugin_EAsyncBlueprintResultSwitch());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCreateCollision, VRExpansionFunctionLibrary_eventGetVRDeviceModelAndTexture_Parms, bool);
			UProperty* NewProp_bCreateCollision = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bCreateCollision"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCreateCollision, VRExpansionFunctionLibrary_eventGetVRDeviceModelAndTexture_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bCreateCollision, VRExpansionFunctionLibrary_eventGetVRDeviceModelAndTexture_Parms), sizeof(bool), true);
			UProperty* NewProp_ProceduralMeshComponentsToFill = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ProceduralMeshComponentsToFill"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(ProceduralMeshComponentsToFill, VRExpansionFunctionLibrary_eventGetVRDeviceModelAndTexture_Parms), 0x0010008000000080);
			UProperty* NewProp_ProceduralMeshComponentsToFill_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ProceduralMeshComponentsToFill, TEXT("ProceduralMeshComponentsToFill"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000080000, Z_Construct_UClass_UProceduralMeshComponent_NoRegister());
			UProperty* NewProp_DeviceType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeviceType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(DeviceType, VRExpansionFunctionLibrary_eventGetVRDeviceModelAndTexture_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EBPSteamVRTrackedDeviceType());
			UProperty* NewProp_WorldContextObject = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldContextObject"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(WorldContextObject, VRExpansionFunctionLibrary_eventGetVRDeviceModelAndTexture_Parms), 0x0010000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRExpansionFunctions|SteamVR"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetVRDeviceModelAndTexture"));
			MetaData->SetValue(ReturnFunction, TEXT("ExpandEnumAsExecs"), TEXT("Result"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT(", TArray<uint8> & OutRawTexture, bool bReturnRawTexture = false"));
			MetaData->SetValue(ReturnFunction, TEXT("WorldContext"), TEXT("WorldContextObject"));
			MetaData->SetValue(NewProp_ProceduralMeshComponentsToFill, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDevicePropertyBool()
	{
		struct VRExpansionFunctionLibrary_eventGetVRDevicePropertyBool_Parms
		{
			TEnumAsByte<EVRDeviceProperty_Bool> PropertyToRetrieve;
			int32 DeviceID;
			bool BoolValue;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRDevicePropertyBool"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(VRExpansionFunctionLibrary_eventGetVRDevicePropertyBool_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyBool_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyBool_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyBool_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(BoolValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyBool_Parms, bool);
			UProperty* NewProp_BoolValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("BoolValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(BoolValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyBool_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(BoolValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyBool_Parms), sizeof(bool), true);
			UProperty* NewProp_DeviceID = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeviceID"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(DeviceID, VRExpansionFunctionLibrary_eventGetVRDevicePropertyBool_Parms), 0x0010000000000080);
			UProperty* NewProp_PropertyToRetrieve = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PropertyToRetrieve"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(PropertyToRetrieve, VRExpansionFunctionLibrary_eventGetVRDevicePropertyBool_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Bool());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRExpansionFunctions|SteamVR"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetVRDevicePropertyBool"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets a Bool device property"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDevicePropertyFloat()
	{
		struct VRExpansionFunctionLibrary_eventGetVRDevicePropertyFloat_Parms
		{
			TEnumAsByte<EVRDeviceProperty_Float> PropertyToRetrieve;
			int32 DeviceID;
			float FloatValue;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRDevicePropertyFloat"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(VRExpansionFunctionLibrary_eventGetVRDevicePropertyFloat_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyFloat_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyFloat_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyFloat_Parms), sizeof(bool), true);
			UProperty* NewProp_FloatValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FloatValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FloatValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyFloat_Parms), 0x0010000000000180);
			UProperty* NewProp_DeviceID = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeviceID"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(DeviceID, VRExpansionFunctionLibrary_eventGetVRDevicePropertyFloat_Parms), 0x0010000000000080);
			UProperty* NewProp_PropertyToRetrieve = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PropertyToRetrieve"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(PropertyToRetrieve, VRExpansionFunctionLibrary_eventGetVRDevicePropertyFloat_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_Float());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRExpansionFunctions|SteamVR"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetVRDevicePropertyFloat"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets a Float device property"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDevicePropertyString()
	{
		struct VRExpansionFunctionLibrary_eventGetVRDevicePropertyString_Parms
		{
			EVRDeviceProperty_String PropertyToRetrieve;
			int32 DeviceID;
			FString StringValue;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRDevicePropertyString"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04420401, 65535, sizeof(VRExpansionFunctionLibrary_eventGetVRDevicePropertyString_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyString_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyString_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyString_Parms), sizeof(bool), true);
			UProperty* NewProp_StringValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("StringValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStrProperty(CPP_PROPERTY_BASE(StringValue, VRExpansionFunctionLibrary_eventGetVRDevicePropertyString_Parms), 0x0010000000000180);
			UProperty* NewProp_DeviceID = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeviceID"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(DeviceID, VRExpansionFunctionLibrary_eventGetVRDevicePropertyString_Parms), 0x0010000000000080);
			UProperty* NewProp_PropertyToRetrieve = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PropertyToRetrieve"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(PropertyToRetrieve, VRExpansionFunctionLibrary_eventGetVRDevicePropertyString_Parms), 0x0010000000000080, Z_Construct_UEnum_VRExpansionPlugin_EVRDeviceProperty_String());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRExpansionFunctions|SteamVR"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GetVRDevicePropertyString"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets a String device property"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_IsInVREditorPreviewOrGame()
	{
		struct VRExpansionFunctionLibrary_eventIsInVREditorPreviewOrGame_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsInVREditorPreviewOrGame"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14022401, 65535, sizeof(VRExpansionFunctionLibrary_eventIsInVREditorPreviewOrGame_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRExpansionFunctionLibrary_eventIsInVREditorPreviewOrGame_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRExpansionFunctionLibrary_eventIsInVREditorPreviewOrGame_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRExpansionFunctionLibrary_eventIsInVREditorPreviewOrGame_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRExpansionFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("IsInVREditorPreviewOrGame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets whether the game is running in VRPreview or is a non editor build game (returns true for either)."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRExpansionFunctionLibrary_OpenVRHandles()
	{
		struct VRExpansionFunctionLibrary_eventOpenVRHandles_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRExpansionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OpenVRHandles"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(VRExpansionFunctionLibrary_eventOpenVRHandles_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRExpansionFunctionLibrary_eventOpenVRHandles_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRExpansionFunctionLibrary_eventOpenVRHandles_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRExpansionFunctionLibrary_eventOpenVRHandles_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("bIgnoreSelf"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRExpansionFunctions|SteamVR"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Opends the handles for the library"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UVRExpansionFunctionLibrary_NoRegister()
	{
		return UVRExpansionFunctionLibrary::StaticClass();
	}
	UClass* Z_Construct_UClass_UVRExpansionFunctionLibrary()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UVRExpansionFunctionLibrary::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_CloseVRHandles());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetGripSlotInRangeByTypeName());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetGripSlotInRangeByTypeName_Component());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetHMDPureYaw());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetHMDType());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetIsActorMovable());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetIsHMDConnected());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRControllerPropertyString());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDeviceModelAndTexture());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDevicePropertyBool());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDevicePropertyFloat());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDevicePropertyString());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_IsInVREditorPreviewOrGame());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRExpansionFunctionLibrary_OpenVRHandles());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bInitialized, UVRExpansionFunctionLibrary, bool);
				UProperty* NewProp_bInitialized = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bInitialized"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bInitialized, UVRExpansionFunctionLibrary), 0x0010000000000014, CPP_BOOL_PROPERTY_BITMASK(bInitialized, UVRExpansionFunctionLibrary), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_CloseVRHandles(), "CloseVRHandles"); // 2088337639
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetGripSlotInRangeByTypeName(), "GetGripSlotInRangeByTypeName"); // 950844629
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetGripSlotInRangeByTypeName_Component(), "GetGripSlotInRangeByTypeName_Component"); // 2318953703
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetHMDPureYaw(), "GetHMDPureYaw"); // 4188027958
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetHMDType(), "GetHMDType"); // 1315315501
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetIsActorMovable(), "GetIsActorMovable"); // 3664470251
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetIsHMDConnected(), "GetIsHMDConnected"); // 1189561827
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRControllerPropertyString(), "GetVRControllerPropertyString"); // 4210944085
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDeviceModelAndTexture(), "GetVRDeviceModelAndTexture"); // 2436877093
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDevicePropertyBool(), "GetVRDevicePropertyBool"); // 3406835641
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDevicePropertyFloat(), "GetVRDevicePropertyFloat"); // 3897223558
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_GetVRDevicePropertyString(), "GetVRDevicePropertyString"); // 1256575288
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_IsInVREditorPreviewOrGame(), "IsInVREditorPreviewOrGame"); // 3080247047
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRExpansionFunctionLibrary_OpenVRHandles(), "OpenVRHandles"); // 3123181541
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("VRExpansionFunctionLibrary.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Had to turn this in to a UObject, I felt the easiest way to use it was as an actor component to the player controller\nIt can be returned to just a blueprint library if epic ever upgrade steam to 1.33 or above"));
				MetaData->SetValue(NewProp_bInitialized, TEXT("Category"), TEXT("VRExpansionFunctionLibrary"));
				MetaData->SetValue(NewProp_bInitialized, TEXT("ModuleRelativePath"), TEXT("Public/VRExpansionFunctionLibrary.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UVRExpansionFunctionLibrary(Z_Construct_UClass_UVRExpansionFunctionLibrary, &UVRExpansionFunctionLibrary::StaticClass, TEXT("UVRExpansionFunctionLibrary"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UVRExpansionFunctionLibrary);
	UFunction* Z_Construct_UFunction_UVRRootComponent_GetVRForwardVector()
	{
		struct VRRootComponent_eventGetVRForwardVector_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRRootComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRForwardVector"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14820401, 65535, sizeof(VRRootComponent_eventGetVRForwardVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRRootComponent_eventGetVRForwardVector_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRCharacter|VRLocations"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRRootComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("FVector GetVROffsetFromLocationAndRotation(FVector Location, const FQuat &Rotation)\n       {\n               FRotator CamRotOffset(0.0f, curCameraRot.Yaw, 0.0f);\n               FTransform testComponentToWorld = FTransform(Rotation, Location, RelativeScale3D);\n\n               return testComponentToWorld.TransformPosition(FVector(curCameraLoc.X, curCameraLoc.Y, CapsuleHalfHeight) + CamRotOffset.RotateVector(VRCapsuleOffset));\n       }"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRRootComponent_GetVRLocation()
	{
		struct VRRootComponent_eventGetVRLocation_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRRootComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14820401, 65535, sizeof(VRRootComponent_eventGetVRLocation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRRootComponent_eventGetVRLocation_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRCharacter|VRLocations"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRRootComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRRootComponent_GetVRRightVector()
	{
		struct VRRootComponent_eventGetVRRightVector_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRRootComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRRightVector"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14820401, 65535, sizeof(VRRootComponent_eventGetVRRightVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRRootComponent_eventGetVRRightVector_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRCharacter|VRLocations"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRRootComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRRootComponent_GetVRRotation()
	{
		struct VRRootComponent_eventGetVRRotation_Parms
		{
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRRootComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14820401, 65535, sizeof(VRRootComponent_eventGetVRRotation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRRootComponent_eventGetVRRotation_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRCharacter|VRLocations"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRRootComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRRootComponent_GetVRUpVector()
	{
		struct VRRootComponent_eventGetVRUpVector_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UVRRootComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRUpVector"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14820401, 65535, sizeof(VRRootComponent_eventGetVRUpVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRRootComponent_eventGetVRUpVector_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRCharacter|VRLocations"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRRootComponent.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UVRRootComponent_NoRegister()
	{
		return UVRRootComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UVRRootComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UCapsuleComponent();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UVRRootComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;

				OuterClass->LinkChild(Z_Construct_UFunction_UVRRootComponent_GetVRForwardVector());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRRootComponent_GetVRLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRRootComponent_GetVRRightVector());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRRootComponent_GetVRRotation());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRRootComponent_GetVRUpVector());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_WalkingCollisionOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WalkingCollisionOverride"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(WalkingCollisionOverride, UVRRootComponent), 0x0010000000000005, Z_Construct_UEnum_Engine_ECollisionChannel());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseWalkingCollisionOverride, UVRRootComponent, bool);
				UProperty* NewProp_bUseWalkingCollisionOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseWalkingCollisionOverride"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseWalkingCollisionOverride, UVRRootComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bUseWalkingCollisionOverride, UVRRootComponent), sizeof(bool), true);
				UProperty* NewProp_VRCapsuleOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRCapsuleOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(VRCapsuleOffset, UVRRootComponent), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_OffsetComponentToWorld = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OffsetComponentToWorld"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OffsetComponentToWorld, UVRRootComponent), 0x0010000000002014, Z_Construct_UScriptStruct_FTransform());
				UProperty* NewProp_TargetPrimitiveComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TargetPrimitiveComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(TargetPrimitiveComponent, UVRRootComponent), 0x001000000008200c, Z_Construct_UClass_USceneComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRRootComponent_GetVRForwardVector(), "GetVRForwardVector"); // 3905598772
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRRootComponent_GetVRLocation(), "GetVRLocation"); // 2844707334
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRRootComponent_GetVRRightVector(), "GetVRRightVector"); // 845450970
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRRootComponent_GetVRRotation(), "GetVRRotation"); // 1974406143
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRRootComponent_GetVRUpVector(), "GetVRUpVector"); // 2208447959
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("VRExpansionLibrary"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object LOD Lighting TextureStreaming Object LOD Lighting TextureStreaming Activation Components|Activation Trigger"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("VRRootComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/VRRootComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("EXPERIMENTAL, don't use"));
				MetaData->SetValue(NewProp_WalkingCollisionOverride, TEXT("Category"), TEXT("VRExpansionLibrary"));
				MetaData->SetValue(NewProp_WalkingCollisionOverride, TEXT("ModuleRelativePath"), TEXT("Public/VRRootComponent.h"));
				MetaData->SetValue(NewProp_bUseWalkingCollisionOverride, TEXT("Category"), TEXT("VRExpansionLibrary"));
				MetaData->SetValue(NewProp_bUseWalkingCollisionOverride, TEXT("ModuleRelativePath"), TEXT("Public/VRRootComponent.h"));
				MetaData->SetValue(NewProp_VRCapsuleOffset, TEXT("Category"), TEXT("VRExpansionLibrary"));
				MetaData->SetValue(NewProp_VRCapsuleOffset, TEXT("ModuleRelativePath"), TEXT("Public/VRRootComponent.h"));
				MetaData->SetValue(NewProp_VRCapsuleOffset, TEXT("ToolTip"), TEXT("Used to offset the collision (IE backwards from the player slightly."));
				MetaData->SetValue(NewProp_OffsetComponentToWorld, TEXT("Category"), TEXT("VRExpansionLibrary"));
				MetaData->SetValue(NewProp_OffsetComponentToWorld, TEXT("ModuleRelativePath"), TEXT("Public/VRRootComponent.h"));
				MetaData->SetValue(NewProp_TargetPrimitiveComponent, TEXT("Category"), TEXT("VRExpansionLibrary"));
				MetaData->SetValue(NewProp_TargetPrimitiveComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_TargetPrimitiveComponent, TEXT("ModuleRelativePath"), TEXT("Public/VRRootComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UVRRootComponent(Z_Construct_UClass_UVRRootComponent, &UVRRootComponent::StaticClass, TEXT("UVRRootComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UVRRootComponent);
	UFunction* Z_Construct_UFunction_UVRCharacterMovementComponent_ServerMoveVR()
	{
		UObject* Outer=Z_Construct_UClass_UVRCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ServerMoveVR"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220C40, 65535, sizeof(VRCharacterMovementComponent_eventServerMoveVR_Parms));
			UProperty* NewProp_ClientMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ClientMovementMode, VRCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientBaseBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientBaseBoneName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(ClientBaseBoneName, VRCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientMovementBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementBase"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ClientMovementBase, VRCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_View = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View"), RF_Public|RF_Transient|RF_MarkAsNative) UUInt32Property(CPP_PROPERTY_BASE(View, VRCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientRoll = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientRoll"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ClientRoll, VRCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080);
			UProperty* NewProp_CompressedMoveFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CompressedMoveFlags"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CompressedMoveFlags, VRCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080);
			UProperty* NewProp_CapsuleYaw = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CapsuleYaw"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CapsuleYaw, VRCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080);
			UProperty* NewProp_LFDiff = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LFDiff"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LFDiff, VRCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_rRequestedVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("rRequestedVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(rRequestedVelocity, VRCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_CapsuleLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CapsuleLoc"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(CapsuleLoc, VRCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_ClientLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientLoc"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ClientLoc, VRCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_InAccel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InAccel, VRCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, VRCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Replicated function sent by client to server - contains client movement and view info."));
			MetaData->SetValue(NewProp_ClientMovementBase, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRCharacterMovementComponent_ServerMoveVRDual()
	{
		UObject* Outer=Z_Construct_UClass_UVRCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ServerMoveVRDual"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220C40, 65535, sizeof(VRCharacterMovementComponent_eventServerMoveVRDual_Parms));
			UProperty* NewProp_ClientMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ClientMovementMode, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientBaseBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientBaseBoneName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(ClientBaseBoneName, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientMovementBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementBase"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ClientMovementBase, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_View = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View"), RF_Public|RF_Transient|RF_MarkAsNative) UUInt32Property(CPP_PROPERTY_BASE(View, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientRoll = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientRoll"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ClientRoll, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_NewFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewFlags"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(NewFlags, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_CapsuleYaw = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CapsuleYaw"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CapsuleYaw, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_LFDiff = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LFDiff"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LFDiff, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_rRequestedVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("rRequestedVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(rRequestedVelocity, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_CapsuleLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CapsuleLoc"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(CapsuleLoc, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_ClientLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientLoc"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ClientLoc, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_InAccel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InAccel, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_OldCapsuleYaw = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldCapsuleYaw"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(OldCapsuleYaw, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_OldLFDiff = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldLFDiff"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OldLFDiff, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_rOldRequestedVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("rOldRequestedVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(rOldRequestedVelocity, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_OldCapsuleLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldCapsuleLoc"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OldCapsuleLoc, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_View0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View0"), RF_Public|RF_Transient|RF_MarkAsNative) UUInt32Property(CPP_PROPERTY_BASE(View0, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_PendingFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PendingFlags"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(PendingFlags, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_InAccel0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel0"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InAccel0, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp0"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp0, VRCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Replicated function sent by client to server - contains client movement and view info for two moves."));
			MetaData->SetValue(NewProp_ClientMovementBase, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRCharacterMovementComponent_ServerMoveVRDualHybridRootMotion()
	{
		UObject* Outer=Z_Construct_UClass_UVRCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ServerMoveVRDualHybridRootMotion"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220C40, 65535, sizeof(VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms));
			UProperty* NewProp_ClientMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ClientMovementMode, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientBaseBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientBaseBoneName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(ClientBaseBoneName, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientMovementBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementBase"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ClientMovementBase, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_View = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View"), RF_Public|RF_Transient|RF_MarkAsNative) UUInt32Property(CPP_PROPERTY_BASE(View, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientRoll = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientRoll"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ClientRoll, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_NewFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewFlags"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(NewFlags, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_CapsuleYaw = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CapsuleYaw"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CapsuleYaw, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_LFDiff = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LFDiff"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LFDiff, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_rRequestedVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("rRequestedVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(rRequestedVelocity, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_CapsuleLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CapsuleLoc"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(CapsuleLoc, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_ClientLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientLoc"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ClientLoc, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_InAccel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InAccel, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_OldCapsuleYaw = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldCapsuleYaw"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(OldCapsuleYaw, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_OldLFDiff = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldLFDiff"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OldLFDiff, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_rOldRequestedVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("rOldRequestedVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(rOldRequestedVelocity, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_OldCapsuleLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldCapsuleLoc"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OldCapsuleLoc, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_View0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View0"), RF_Public|RF_Transient|RF_MarkAsNative) UUInt32Property(CPP_PROPERTY_BASE(View0, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_PendingFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PendingFlags"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(PendingFlags, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_InAccel0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel0"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InAccel0, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp0"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp0, VRCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Replicated function sent by client to server - contains client movement and view info for two moves. First move is non root motion, second is root motion."));
			MetaData->SetValue(NewProp_ClientMovementBase, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UVRCharacterMovementComponent_NoRegister()
	{
		return UVRCharacterMovementComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UVRCharacterMovementComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UCharacterMovementComponent();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UVRCharacterMovementComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00084;

				OuterClass->LinkChild(Z_Construct_UFunction_UVRCharacterMovementComponent_ServerMoveVR());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRCharacterMovementComponent_ServerMoveVRDual());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRCharacterMovementComponent_ServerMoveVRDualHybridRootMotion());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_WallRepulsionMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WallRepulsionMultiplier"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(WallRepulsionMultiplier, UVRCharacterMovementComponent), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAllowMovementMerging, UVRCharacterMovementComponent, bool);
				UProperty* NewProp_bAllowMovementMerging = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAllowMovementMerging"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAllowMovementMerging, UVRCharacterMovementComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bAllowMovementMerging, UVRCharacterMovementComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAllowWalkingThroughWalls, UVRCharacterMovementComponent, bool);
				UProperty* NewProp_bAllowWalkingThroughWalls = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAllowWalkingThroughWalls"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAllowWalkingThroughWalls, UVRCharacterMovementComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bAllowWalkingThroughWalls, UVRCharacterMovementComponent), sizeof(bool), true);
				UProperty* NewProp_VRRootCapsule = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRRootCapsule"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(VRRootCapsule, UVRCharacterMovementComponent), 0x001000000008201c, Z_Construct_UClass_UVRRootComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRCharacterMovementComponent_ServerMoveVR(), "ServerMoveVR"); // 2130854836
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRCharacterMovementComponent_ServerMoveVRDual(), "ServerMoveVRDual"); // 3275775300
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRCharacterMovementComponent_ServerMoveVRDualHybridRootMotion(), "ServerMoveVRDualHybridRootMotion"); // 3558965086
				OuterClass->ClassConfigName = FName(TEXT("Engine"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("VRCharacterMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacterMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ObjectInitializerConstructorDeclared"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FAIMoveCompletedSignature, FAIRequestID, RequestID, EPathFollowingResult::Type, Result);"));
				MetaData->SetValue(NewProp_WallRepulsionMultiplier, TEXT("Category"), TEXT("VRCharacterMovementComponent"));
				MetaData->SetValue(NewProp_WallRepulsionMultiplier, TEXT("ClampMax"), TEXT("1.0"));
				MetaData->SetValue(NewProp_WallRepulsionMultiplier, TEXT("ClampMin"), TEXT("0.01"));
				MetaData->SetValue(NewProp_WallRepulsionMultiplier, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_WallRepulsionMultiplier, TEXT("ToolTip"), TEXT("Higher values will cause more slide but better step up"));
				MetaData->SetValue(NewProp_WallRepulsionMultiplier, TEXT("UIMax"), TEXT("1"));
				MetaData->SetValue(NewProp_WallRepulsionMultiplier, TEXT("UIMin"), TEXT("0"));
				MetaData->SetValue(NewProp_bAllowMovementMerging, TEXT("Category"), TEXT("VRCharacterMovementComponent"));
				MetaData->SetValue(NewProp_bAllowMovementMerging, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bAllowMovementMerging, TEXT("ToolTip"), TEXT("Allow merging movement replication (may cause issues when >10 players due to capsule location"));
				MetaData->SetValue(NewProp_bAllowWalkingThroughWalls, TEXT("Category"), TEXT("VRCharacterMovementComponent"));
				MetaData->SetValue(NewProp_bAllowWalkingThroughWalls, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_bAllowWalkingThroughWalls, TEXT("ToolTip"), TEXT("UPROPERTY(BlueprintReadOnly, Transient, Category = VRMovement)\nUCapsuleComponent * VRCameraCollider;"));
				MetaData->SetValue(NewProp_VRRootCapsule, TEXT("Category"), TEXT("VRMovement"));
				MetaData->SetValue(NewProp_VRRootCapsule, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_VRRootCapsule, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacterMovementComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UVRCharacterMovementComponent(Z_Construct_UClass_UVRCharacterMovementComponent, &UVRCharacterMovementComponent::StaticClass, TEXT("UVRCharacterMovementComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UVRCharacterMovementComponent);
	UFunction* Z_Construct_UFunction_AVRCharacter_ExtendedSimpleMoveToLocation()
	{
		struct VRCharacter_eventExtendedSimpleMoveToLocation_Parms
		{
			FVector GoalLocation;
			float AcceptanceRadius;
			bool bStopOnOverlap;
			bool bUsePathfinding;
			bool bProjectDestinationToNavigation;
			bool bCanStrafe;
			TSubclassOf<UNavigationQueryFilter>  FilterClass;
			bool bAllowPartialPath;
		};
		UObject* Outer=Z_Construct_UClass_AVRCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ExtendedSimpleMoveToLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(VRCharacter_eventExtendedSimpleMoveToLocation_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAllowPartialPath, VRCharacter_eventExtendedSimpleMoveToLocation_Parms, bool);
			UProperty* NewProp_bAllowPartialPath = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bAllowPartialPath"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAllowPartialPath, VRCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010040000000080, CPP_BOOL_PROPERTY_BITMASK(bAllowPartialPath, VRCharacter_eventExtendedSimpleMoveToLocation_Parms), sizeof(bool), true);
			UProperty* NewProp_FilterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FilterClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(FilterClass, VRCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0014000000000080, Z_Construct_UClass_UNavigationQueryFilter_NoRegister(), UClass::StaticClass());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanStrafe, VRCharacter_eventExtendedSimpleMoveToLocation_Parms, bool);
			UProperty* NewProp_bCanStrafe = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bCanStrafe"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanStrafe, VRCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010040000000080, CPP_BOOL_PROPERTY_BITMASK(bCanStrafe, VRCharacter_eventExtendedSimpleMoveToLocation_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bProjectDestinationToNavigation, VRCharacter_eventExtendedSimpleMoveToLocation_Parms, bool);
			UProperty* NewProp_bProjectDestinationToNavigation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bProjectDestinationToNavigation"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bProjectDestinationToNavigation, VRCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bProjectDestinationToNavigation, VRCharacter_eventExtendedSimpleMoveToLocation_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUsePathfinding, VRCharacter_eventExtendedSimpleMoveToLocation_Parms, bool);
			UProperty* NewProp_bUsePathfinding = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUsePathfinding"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUsePathfinding, VRCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bUsePathfinding, VRCharacter_eventExtendedSimpleMoveToLocation_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bStopOnOverlap, VRCharacter_eventExtendedSimpleMoveToLocation_Parms, bool);
			UProperty* NewProp_bStopOnOverlap = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bStopOnOverlap"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bStopOnOverlap, VRCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010040000000080, CPP_BOOL_PROPERTY_BITMASK(bStopOnOverlap, VRCharacter_eventExtendedSimpleMoveToLocation_Parms), sizeof(bool), true);
			UProperty* NewProp_AcceptanceRadius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AcceptanceRadius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(AcceptanceRadius, VRCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010000000000080);
			UProperty* NewProp_GoalLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GoalLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GoalLocation, VRCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AdvancedDisplay"), TEXT("bStopOnOverlap,bCanStrafe,bAllowPartialPath"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRCharacter"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_AcceptanceRadius"), TEXT("-1.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bAllowPartialPath"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bCanStrafe"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bProjectDestinationToNavigation"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bStopOnOverlap"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUsePathfinding"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("An extended simple move to location with additional parameters"));
			MetaData->SetValue(NewProp_GoalLocation, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRCharacter_GetMoveStatus()
	{
		struct VRCharacter_eventGetMoveStatus_Parms
		{
			TEnumAsByte<EPathFollowingStatus::Type> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AVRCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetMoveStatus"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(VRCharacter_eventGetMoveStatus_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, VRCharacter_eventGetMoveStatus_Parms), 0x0010000000000580, Z_Construct_UEnum_AIModule_EPathFollowingStatus());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRCharacter"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns status of path following"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRCharacter_GetTeleportLocation()
	{
		struct VRCharacter_eventGetTeleportLocation_Parms
		{
			FVector OriginalLocation;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AVRCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTeleportLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14820401, 65535, sizeof(VRCharacter_eventGetTeleportLocation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRCharacter_eventGetTeleportLocation_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OriginalLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OriginalLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OriginalLocation, VRCharacter_eventGetTeleportLocation_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("A helper function that offsets a given vector by the roots collision location\npass in a teleport location and it provides the correct spot for it to be at your feet"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRCharacter_HasPartialPath()
	{
		struct VRCharacter_eventHasPartialPath_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AVRCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HasPartialPath"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(VRCharacter_eventHasPartialPath_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRCharacter_eventHasPartialPath_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRCharacter_eventHasPartialPath_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRCharacter_eventHasPartialPath_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRCharacter"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns true if the current PathFollowingComponent's path is partial (does not reach desired destination)."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRCharacter_NotifyOfTeleport()
	{
		UObject* Outer=Z_Construct_UClass_AVRCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("NotifyOfTeleport"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00024CC0, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRCharacter_ReceiveNavigationMoveCompleted()
	{
		UObject* Outer=Z_Construct_UClass_AVRCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ReceiveNavigationMoveCompleted"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(VRCharacter_eventReceiveNavigationMoveCompleted_Parms));
			UProperty* NewProp_PathingResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PathingResult"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(PathingResult, VRCharacter_eventReceiveNavigationMoveCompleted_Parms), 0x0010000000000080, Z_Construct_UEnum_AIModule_EPathFollowingResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRCharacter"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event when a navigation pathing operation has completed, auto calls stop movement for VR characters"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRCharacter_StopNavigationMovement()
	{
		UObject* Outer=Z_Construct_UClass_AVRCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopNavigationMovement"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRCharacter"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Instantly stops pathing"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AVRCharacter_NoRegister()
	{
		return AVRCharacter::StaticClass();
	}
	UClass* Z_Construct_UClass_AVRCharacter()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ACharacter();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = AVRCharacter::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_AVRCharacter_ExtendedSimpleMoveToLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRCharacter_GetMoveStatus());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRCharacter_GetTeleportLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRCharacter_HasPartialPath());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRCharacter_NotifyOfTeleport());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRCharacter_ReceiveNavigationMoveCompleted());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRCharacter_StopNavigationMovement());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_DefaultNavigationFilterClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultNavigationFilterClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(DefaultNavigationFilterClass, AVRCharacter), 0x0014000000000004, Z_Construct_UClass_UNavigationQueryFilter_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_RightMotionController = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RightMotionController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(RightMotionController, AVRCharacter), 0x00100000000a001d, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
				UProperty* NewProp_LeftMotionController = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LeftMotionController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(LeftMotionController, AVRCharacter), 0x00100000000a001d, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
				UProperty* NewProp_ParentRelativeAttachment = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ParentRelativeAttachment"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ParentRelativeAttachment, AVRCharacter), 0x00100000000a001d, Z_Construct_UClass_UParentRelativeAttachmentComponent_NoRegister());
				UProperty* NewProp_VRReplicatedCamera = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRReplicatedCamera"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(VRReplicatedCamera, AVRCharacter), 0x00100000000a001d, Z_Construct_UClass_UReplicatedVRCameraComponent_NoRegister());
				UProperty* NewProp_VRMovementReference = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRMovementReference"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(VRMovementReference, AVRCharacter), 0x00100000000a201d, Z_Construct_UClass_UVRCharacterMovementComponent_NoRegister());
				UProperty* NewProp_VRRootReference = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRRootReference"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(VRRootReference, AVRCharacter), 0x00100000000a201d, Z_Construct_UClass_UVRRootComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRCharacter_ExtendedSimpleMoveToLocation(), "ExtendedSimpleMoveToLocation"); // 1020283031
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRCharacter_GetMoveStatus(), "GetMoveStatus"); // 3086212581
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRCharacter_GetTeleportLocation(), "GetTeleportLocation"); // 3183141129
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRCharacter_HasPartialPath(), "HasPartialPath"); // 1667827413
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRCharacter_NotifyOfTeleport(), "NotifyOfTeleport"); // 4163682109
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRCharacter_ReceiveNavigationMoveCompleted(), "ReceiveNavigationMoveCompleted"); // 2373796483
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRCharacter_StopNavigationMovement(), "StopNavigationMovement"); // 877484041
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Navigation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("VRCharacter.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
				MetaData->SetValue(OuterClass, TEXT("ObjectInitializerConstructorDeclared"), TEXT(""));
				MetaData->SetValue(NewProp_DefaultNavigationFilterClass, TEXT("Category"), TEXT("AI"));
				MetaData->SetValue(NewProp_DefaultNavigationFilterClass, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
				MetaData->SetValue(NewProp_RightMotionController, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_RightMotionController, TEXT("Category"), TEXT("VRCharacter"));
				MetaData->SetValue(NewProp_RightMotionController, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_RightMotionController, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
				MetaData->SetValue(NewProp_LeftMotionController, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_LeftMotionController, TEXT("Category"), TEXT("VRCharacter"));
				MetaData->SetValue(NewProp_LeftMotionController, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_LeftMotionController, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
				MetaData->SetValue(NewProp_ParentRelativeAttachment, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_ParentRelativeAttachment, TEXT("Category"), TEXT("VRCharacter"));
				MetaData->SetValue(NewProp_ParentRelativeAttachment, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ParentRelativeAttachment, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
				MetaData->SetValue(NewProp_ParentRelativeAttachment, TEXT("ToolTip"), TEXT("UPROPERTY(Category = VRCharacter, VisibleAnywhere, BlueprintReadOnly, meta = (AllowPrivateAccess = \"true\"))\nUCapsuleComponent * VRCameraCollider;"));
				MetaData->SetValue(NewProp_VRReplicatedCamera, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_VRReplicatedCamera, TEXT("Category"), TEXT("VRCharacter"));
				MetaData->SetValue(NewProp_VRReplicatedCamera, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_VRReplicatedCamera, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
				MetaData->SetValue(NewProp_VRMovementReference, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_VRMovementReference, TEXT("Category"), TEXT("VRCharacter"));
				MetaData->SetValue(NewProp_VRMovementReference, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_VRMovementReference, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
				MetaData->SetValue(NewProp_VRRootReference, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_VRRootReference, TEXT("Category"), TEXT("VRCharacter"));
				MetaData->SetValue(NewProp_VRRootReference, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_VRRootReference, TEXT("ModuleRelativePath"), TEXT("Public/VRCharacter.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AVRCharacter(Z_Construct_UClass_AVRCharacter, &AVRCharacter::StaticClass, TEXT("AVRCharacter"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AVRCharacter);
	UClass* Z_Construct_UClass_UVRPathFollowingComponent_NoRegister()
	{
		return UVRPathFollowingComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UVRPathFollowingComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UPathFollowingComponent();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UVRPathFollowingComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_VRMovementComp = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRMovementComp"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(VRMovementComp, UVRPathFollowingComponent), 0x0010000000082008, Z_Construct_UClass_UVRCharacterMovementComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("VRPathFollowingComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/VRPathFollowingComponent.h"));
				MetaData->SetValue(NewProp_VRMovementComp, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_VRMovementComp, TEXT("ModuleRelativePath"), TEXT("Public/VRPathFollowingComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UVRPathFollowingComponent(Z_Construct_UClass_UVRPathFollowingComponent, &UVRPathFollowingComponent::StaticClass, TEXT("UVRPathFollowingComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UVRPathFollowingComponent);
	UClass* Z_Construct_UClass_AVRPlayerController_NoRegister()
	{
		return AVRPlayerController::StaticClass();
	}
	UClass* Z_Construct_UClass_AVRPlayerController()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_APlayerController();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = AVRPlayerController::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900284;


				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Rendering Utilities|Transformation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("VRPlayerController.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/VRPlayerController.h"));
				MetaData->SetValue(OuterClass, TEXT("ObjectInitializerConstructorDeclared"), TEXT(""));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AVRPlayerController(Z_Construct_UClass_AVRPlayerController, &AVRPlayerController::StaticClass, TEXT("AVRPlayerController"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AVRPlayerController);
	UFunction* Z_Construct_UFunction_UVRSimpleCharacterMovementComponent_ServerMoveVR()
	{
		UObject* Outer=Z_Construct_UClass_UVRSimpleCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ServerMoveVR"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220C40, 65535, sizeof(VRSimpleCharacterMovementComponent_eventServerMoveVR_Parms));
			UProperty* NewProp_ClientMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ClientMovementMode, VRSimpleCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientBaseBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientBaseBoneName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(ClientBaseBoneName, VRSimpleCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientMovementBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementBase"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ClientMovementBase, VRSimpleCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_View = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View"), RF_Public|RF_Transient|RF_MarkAsNative) UUInt32Property(CPP_PROPERTY_BASE(View, VRSimpleCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientRoll = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientRoll"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ClientRoll, VRSimpleCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080);
			UProperty* NewProp_CompressedMoveFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CompressedMoveFlags"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(CompressedMoveFlags, VRSimpleCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080);
			UProperty* NewProp_LFDiff = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LFDiff"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LFDiff, VRSimpleCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_rRequestedVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("rRequestedVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(rRequestedVelocity, VRSimpleCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_ClientLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientLoc"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ClientLoc, VRSimpleCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_InAccel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InAccel, VRSimpleCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, VRSimpleCharacterMovementComponent_eventServerMoveVR_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Replicated function sent by client to server - contains client movement and view info."));
			MetaData->SetValue(NewProp_ClientMovementBase, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRSimpleCharacterMovementComponent_ServerMoveVRDual()
	{
		UObject* Outer=Z_Construct_UClass_UVRSimpleCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ServerMoveVRDual"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220C40, 65535, sizeof(VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms));
			UProperty* NewProp_ClientMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ClientMovementMode, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientBaseBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientBaseBoneName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(ClientBaseBoneName, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientMovementBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementBase"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ClientMovementBase, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_View = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View"), RF_Public|RF_Transient|RF_MarkAsNative) UUInt32Property(CPP_PROPERTY_BASE(View, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientRoll = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientRoll"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ClientRoll, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_NewFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewFlags"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(NewFlags, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_LFDiff = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LFDiff"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LFDiff, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_rRequestedVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("rRequestedVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(rRequestedVelocity, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_ClientLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientLoc"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ClientLoc, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_InAccel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InAccel, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_OldLFDiff = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldLFDiff"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OldLFDiff, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_rOldRequestedVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("rOldRequestedVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(rOldRequestedVelocity, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_View0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View0"), RF_Public|RF_Transient|RF_MarkAsNative) UUInt32Property(CPP_PROPERTY_BASE(View0, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_PendingFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PendingFlags"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(PendingFlags, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			UProperty* NewProp_InAccel0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel0"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InAccel0, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp0"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp0, VRSimpleCharacterMovementComponent_eventServerMoveVRDual_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Replicated function sent by client to server - contains client movement and view info for two moves."));
			MetaData->SetValue(NewProp_ClientMovementBase, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRSimpleCharacterMovementComponent_ServerMoveVRDualHybridRootMotion()
	{
		UObject* Outer=Z_Construct_UClass_UVRSimpleCharacterMovementComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ServerMoveVRDualHybridRootMotion"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x80220C40, 65535, sizeof(VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms));
			UProperty* NewProp_ClientMovementMode = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ClientMovementMode, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientBaseBoneName = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientBaseBoneName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(ClientBaseBoneName, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientMovementBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientMovementBase"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ClientMovementBase, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_View = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View"), RF_Public|RF_Transient|RF_MarkAsNative) UUInt32Property(CPP_PROPERTY_BASE(View, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_ClientRoll = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientRoll"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ClientRoll, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_NewFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewFlags"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(NewFlags, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_LFDiff = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LFDiff"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LFDiff, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_rRequestedVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("rRequestedVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(rRequestedVelocity, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_ClientLoc = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ClientLoc"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ClientLoc, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_InAccel = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InAccel, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_OldLFDiff = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OldLFDiff"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OldLFDiff, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_rOldRequestedVelocity = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("rOldRequestedVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(rOldRequestedVelocity, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize100());
			UProperty* NewProp_View0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("View0"), RF_Public|RF_Transient|RF_MarkAsNative) UUInt32Property(CPP_PROPERTY_BASE(View0, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_PendingFlags = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PendingFlags"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(PendingFlags, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			UProperty* NewProp_InAccel0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("InAccel0"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(InAccel0, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector_NetQuantize10());
			UProperty* NewProp_TimeStamp0 = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TimeStamp0"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeStamp0, VRSimpleCharacterMovementComponent_eventServerMoveVRDualHybridRootMotion_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacterMovementComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Replicated function sent by client to server - contains client movement and view info for two moves. First move is non root motion, second is root motion."));
			MetaData->SetValue(NewProp_ClientMovementBase, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UVRSimpleCharacterMovementComponent_NoRegister()
	{
		return UVRSimpleCharacterMovementComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UVRSimpleCharacterMovementComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UCharacterMovementComponent();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UVRSimpleCharacterMovementComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00084;

				OuterClass->LinkChild(Z_Construct_UFunction_UVRSimpleCharacterMovementComponent_ServerMoveVR());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRSimpleCharacterMovementComponent_ServerMoveVRDual());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRSimpleCharacterMovementComponent_ServerMoveVRDualHybridRootMotion());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_VRCameraComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRCameraComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(VRCameraComponent, UVRSimpleCharacterMovementComponent), 0x001000000008201c, Z_Construct_UClass_UCameraComponent_NoRegister());
				UProperty* NewProp_VRRootCapsule = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRRootCapsule"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(VRRootCapsule, UVRSimpleCharacterMovementComponent), 0x001000000008201c, Z_Construct_UClass_UCapsuleComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRSimpleCharacterMovementComponent_ServerMoveVR(), "ServerMoveVR"); // 3483881300
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRSimpleCharacterMovementComponent_ServerMoveVRDual(), "ServerMoveVRDual"); // 876732556
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRSimpleCharacterMovementComponent_ServerMoveVRDualHybridRootMotion(), "ServerMoveVRDualHybridRootMotion"); // 377109609
				OuterClass->ClassConfigName = FName(TEXT("Engine"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("SimpleChar/VRSimpleCharacterMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacterMovementComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ObjectInitializerConstructorDeclared"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FAIMoveCompletedSignature, FAIRequestID, RequestID, EPathFollowingResult::Type, Result);"));
				MetaData->SetValue(NewProp_VRCameraComponent, TEXT("Category"), TEXT("VRMovement"));
				MetaData->SetValue(NewProp_VRCameraComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_VRCameraComponent, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacterMovementComponent.h"));
				MetaData->SetValue(NewProp_VRRootCapsule, TEXT("Category"), TEXT("VRMovement"));
				MetaData->SetValue(NewProp_VRRootCapsule, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_VRRootCapsule, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacterMovementComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UVRSimpleCharacterMovementComponent(Z_Construct_UClass_UVRSimpleCharacterMovementComponent, &UVRSimpleCharacterMovementComponent::StaticClass, TEXT("UVRSimpleCharacterMovementComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UVRSimpleCharacterMovementComponent);
	UFunction* Z_Construct_UFunction_AVRSimpleCharacter_ExtendedSimpleMoveToLocation()
	{
		struct VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms
		{
			FVector GoalLocation;
			float AcceptanceRadius;
			bool bStopOnOverlap;
			bool bUsePathfinding;
			bool bProjectDestinationToNavigation;
			bool bCanStrafe;
			TSubclassOf<UNavigationQueryFilter>  FilterClass;
			bool bAllowPartialPath;
		};
		UObject* Outer=Z_Construct_UClass_AVRSimpleCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ExtendedSimpleMoveToLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAllowPartialPath, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms, bool);
			UProperty* NewProp_bAllowPartialPath = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bAllowPartialPath"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAllowPartialPath, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010040000000080, CPP_BOOL_PROPERTY_BITMASK(bAllowPartialPath, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms), sizeof(bool), true);
			UProperty* NewProp_FilterClass = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("FilterClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(FilterClass, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0014000000000080, Z_Construct_UClass_UNavigationQueryFilter_NoRegister(), UClass::StaticClass());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bCanStrafe, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms, bool);
			UProperty* NewProp_bCanStrafe = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bCanStrafe"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bCanStrafe, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010040000000080, CPP_BOOL_PROPERTY_BITMASK(bCanStrafe, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bProjectDestinationToNavigation, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms, bool);
			UProperty* NewProp_bProjectDestinationToNavigation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bProjectDestinationToNavigation"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bProjectDestinationToNavigation, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bProjectDestinationToNavigation, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUsePathfinding, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms, bool);
			UProperty* NewProp_bUsePathfinding = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bUsePathfinding"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUsePathfinding, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bUsePathfinding, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bStopOnOverlap, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms, bool);
			UProperty* NewProp_bStopOnOverlap = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bStopOnOverlap"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bStopOnOverlap, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010040000000080, CPP_BOOL_PROPERTY_BITMASK(bStopOnOverlap, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms), sizeof(bool), true);
			UProperty* NewProp_AcceptanceRadius = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AcceptanceRadius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(AcceptanceRadius, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010000000000080);
			UProperty* NewProp_GoalLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GoalLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GoalLocation, VRSimpleCharacter_eventExtendedSimpleMoveToLocation_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("AdvancedDisplay"), TEXT("bStopOnOverlap,bCanStrafe,bAllowPartialPath"));
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRSimpleCharacter"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_AcceptanceRadius"), TEXT("-1.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bAllowPartialPath"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bCanStrafe"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bProjectDestinationToNavigation"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bStopOnOverlap"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_bUsePathfinding"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("An extended simple move to location with additional parameters"));
			MetaData->SetValue(NewProp_GoalLocation, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetMoveStatus()
	{
		struct VRSimpleCharacter_eventGetMoveStatus_Parms
		{
			TEnumAsByte<EPathFollowingStatus::Type> ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AVRSimpleCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetMoveStatus"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(VRSimpleCharacter_eventGetMoveStatus_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(ReturnValue, VRSimpleCharacter_eventGetMoveStatus_Parms), 0x0010000000000580, Z_Construct_UEnum_AIModule_EPathFollowingStatus());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRSimpleCharacter"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns status of path following"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetTeleportLocation()
	{
		struct VRSimpleCharacter_eventGetTeleportLocation_Parms
		{
			FVector OriginalLocation;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AVRSimpleCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTeleportLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14820401, 65535, sizeof(VRSimpleCharacter_eventGetTeleportLocation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRSimpleCharacter_eventGetTeleportLocation_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OriginalLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OriginalLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OriginalLocation, VRSimpleCharacter_eventGetTeleportLocation_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("A helper function that offsets a given vector by the roots collision location\npass in a teleport location and it provides the correct spot for it to be at your feet"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetVRForwardVector()
	{
		struct VRSimpleCharacter_eventGetVRForwardVector_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AVRSimpleCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRForwardVector"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14820401, 65535, sizeof(VRSimpleCharacter_eventGetVRForwardVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRSimpleCharacter_eventGetVRForwardVector_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SimpleVRCharacter|VRLocations"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetVRLocation()
	{
		struct VRSimpleCharacter_eventGetVRLocation_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AVRSimpleCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14820401, 65535, sizeof(VRSimpleCharacter_eventGetVRLocation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRSimpleCharacter_eventGetVRLocation_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SimpleVRCharacter|VRLocations"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetVRRightVector()
	{
		struct VRSimpleCharacter_eventGetVRRightVector_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AVRSimpleCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRRightVector"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14820401, 65535, sizeof(VRSimpleCharacter_eventGetVRRightVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRSimpleCharacter_eventGetVRRightVector_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SimpleVRCharacter|VRLocations"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetVRRotation()
	{
		struct VRSimpleCharacter_eventGetVRRotation_Parms
		{
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AVRSimpleCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14820401, 65535, sizeof(VRSimpleCharacter_eventGetVRRotation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRSimpleCharacter_eventGetVRRotation_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SimpleVRCharacter|VRLocations"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRSimpleCharacter_GetVRUpVector()
	{
		struct VRSimpleCharacter_eventGetVRUpVector_Parms
		{
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AVRSimpleCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetVRUpVector"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14820401, 65535, sizeof(VRSimpleCharacter_eventGetVRUpVector_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRSimpleCharacter_eventGetVRUpVector_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SimpleVRCharacter|VRLocations"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRSimpleCharacter_HasPartialPath()
	{
		struct VRSimpleCharacter_eventHasPartialPath_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AVRSimpleCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HasPartialPath"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(VRSimpleCharacter_eventHasPartialPath_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRSimpleCharacter_eventHasPartialPath_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRSimpleCharacter_eventHasPartialPath_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRSimpleCharacter_eventHasPartialPath_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRSimpleCharacter"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns true if the current PathFollowingComponent's path is partial (does not reach desired destination)."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRSimpleCharacter_NotifyOfTeleport()
	{
		UObject* Outer=Z_Construct_UClass_AVRSimpleCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("NotifyOfTeleport"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00024CC0, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGrip"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRSimpleCharacter_ReceiveNavigationMoveCompleted()
	{
		UObject* Outer=Z_Construct_UClass_AVRSimpleCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ReceiveNavigationMoveCompleted"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(VRSimpleCharacter_eventReceiveNavigationMoveCompleted_Parms));
			UProperty* NewProp_PathingResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PathingResult"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(PathingResult, VRSimpleCharacter_eventReceiveNavigationMoveCompleted_Parms), 0x0010000000000080, Z_Construct_UEnum_AIModule_EPathFollowingResult());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRSimpleCharacter"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event when a navigation pathing operation has completed, auto calls stop movement for VR characters"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AVRSimpleCharacter_StopNavigationMovement()
	{
		UObject* Outer=Z_Construct_UClass_AVRSimpleCharacter();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StopNavigationMovement"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRSimpleCharacter"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Instantly stops pathing"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AVRSimpleCharacter_NoRegister()
	{
		return AVRSimpleCharacter::StaticClass();
	}
	UClass* Z_Construct_UClass_AVRSimpleCharacter()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ACharacter();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = AVRSimpleCharacter::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_AVRSimpleCharacter_ExtendedSimpleMoveToLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRSimpleCharacter_GetMoveStatus());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRSimpleCharacter_GetTeleportLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRSimpleCharacter_GetVRForwardVector());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRSimpleCharacter_GetVRLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRSimpleCharacter_GetVRRightVector());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRSimpleCharacter_GetVRRotation());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRSimpleCharacter_GetVRUpVector());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRSimpleCharacter_HasPartialPath());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRSimpleCharacter_NotifyOfTeleport());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRSimpleCharacter_ReceiveNavigationMoveCompleted());
				OuterClass->LinkChild(Z_Construct_UFunction_AVRSimpleCharacter_StopNavigationMovement());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_DefaultNavigationFilterClass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DefaultNavigationFilterClass"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(DefaultNavigationFilterClass, AVRSimpleCharacter), 0x0014000000000004, Z_Construct_UClass_UNavigationQueryFilter_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_RightMotionController = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RightMotionController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(RightMotionController, AVRSimpleCharacter), 0x00100000000a001d, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
				UProperty* NewProp_LeftMotionController = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LeftMotionController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(LeftMotionController, AVRSimpleCharacter), 0x00100000000a001d, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
				UProperty* NewProp_ParentRelativeAttachment = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ParentRelativeAttachment"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ParentRelativeAttachment, AVRSimpleCharacter), 0x00100000000a001d, Z_Construct_UClass_UParentRelativeAttachmentComponent_NoRegister());
				UProperty* NewProp_VRReplicatedCamera = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRReplicatedCamera"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(VRReplicatedCamera, AVRSimpleCharacter), 0x00100000000a001d, Z_Construct_UClass_UReplicatedVRCameraComponent_NoRegister());
				UProperty* NewProp_VRSceneComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRSceneComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(VRSceneComponent, AVRSimpleCharacter), 0x00100000000a001d, Z_Construct_UClass_USceneComponent_NoRegister());
				UProperty* NewProp_VRMovementReference = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VRMovementReference"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(VRMovementReference, AVRSimpleCharacter), 0x00100000000a201d, Z_Construct_UClass_UVRSimpleCharacterMovementComponent_NoRegister());
				UProperty* NewProp_OffsetComponentToWorld = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OffsetComponentToWorld"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OffsetComponentToWorld, AVRSimpleCharacter), 0x0010000000002014, Z_Construct_UScriptStruct_FTransform());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRSimpleCharacter_ExtendedSimpleMoveToLocation(), "ExtendedSimpleMoveToLocation"); // 3316102529
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRSimpleCharacter_GetMoveStatus(), "GetMoveStatus"); // 153591683
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRSimpleCharacter_GetTeleportLocation(), "GetTeleportLocation"); // 2133268547
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRSimpleCharacter_GetVRForwardVector(), "GetVRForwardVector"); // 238198556
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRSimpleCharacter_GetVRLocation(), "GetVRLocation"); // 4223467752
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRSimpleCharacter_GetVRRightVector(), "GetVRRightVector"); // 875800480
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRSimpleCharacter_GetVRRotation(), "GetVRRotation"); // 3513294915
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRSimpleCharacter_GetVRUpVector(), "GetVRUpVector"); // 99986075
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRSimpleCharacter_HasPartialPath(), "HasPartialPath"); // 1923814337
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRSimpleCharacter_NotifyOfTeleport(), "NotifyOfTeleport"); // 4105371873
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRSimpleCharacter_ReceiveNavigationMoveCompleted(), "ReceiveNavigationMoveCompleted"); // 2059308981
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AVRSimpleCharacter_StopNavigationMovement(), "StopNavigationMovement"); // 1456100875
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Navigation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("SimpleChar/VRSimpleCharacter.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
				MetaData->SetValue(OuterClass, TEXT("ObjectInitializerConstructorDeclared"), TEXT(""));
				MetaData->SetValue(NewProp_DefaultNavigationFilterClass, TEXT("Category"), TEXT("AI"));
				MetaData->SetValue(NewProp_DefaultNavigationFilterClass, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
				MetaData->SetValue(NewProp_RightMotionController, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_RightMotionController, TEXT("Category"), TEXT("VRSimpleCharacter"));
				MetaData->SetValue(NewProp_RightMotionController, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_RightMotionController, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
				MetaData->SetValue(NewProp_LeftMotionController, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_LeftMotionController, TEXT("Category"), TEXT("VRSimpleCharacter"));
				MetaData->SetValue(NewProp_LeftMotionController, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_LeftMotionController, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
				MetaData->SetValue(NewProp_ParentRelativeAttachment, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_ParentRelativeAttachment, TEXT("Category"), TEXT("VRSimpleCharacter"));
				MetaData->SetValue(NewProp_ParentRelativeAttachment, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ParentRelativeAttachment, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
				MetaData->SetValue(NewProp_VRReplicatedCamera, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_VRReplicatedCamera, TEXT("Category"), TEXT("VRSimpleCharacter"));
				MetaData->SetValue(NewProp_VRReplicatedCamera, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_VRReplicatedCamera, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
				MetaData->SetValue(NewProp_VRSceneComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_VRSceneComponent, TEXT("Category"), TEXT("VRSimpleCharacter"));
				MetaData->SetValue(NewProp_VRSceneComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_VRSceneComponent, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
				MetaData->SetValue(NewProp_VRMovementReference, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_VRMovementReference, TEXT("Category"), TEXT("VRSimpleCharacter"));
				MetaData->SetValue(NewProp_VRMovementReference, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_VRMovementReference, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
				MetaData->SetValue(NewProp_OffsetComponentToWorld, TEXT("Category"), TEXT("VRExpansionLibrary"));
				MetaData->SetValue(NewProp_OffsetComponentToWorld, TEXT("ModuleRelativePath"), TEXT("Public/SimpleChar/VRSimpleCharacter.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AVRSimpleCharacter(Z_Construct_UClass_AVRSimpleCharacter, &AVRSimpleCharacter::StaticClass, TEXT("AVRSimpleCharacter"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AVRSimpleCharacter);
	UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin()
	{
		static UPackage* ReturnPackage = NULL;
		if (!ReturnPackage)
		{
			ReturnPackage = CastChecked<UPackage>(StaticFindObjectFast(UPackage::StaticClass(), NULL, FName(TEXT("/Script/VRExpansionPlugin")), false, false));
			ReturnPackage->SetPackageFlags(PKG_CompiledIn | 0x00000000);
			FGuid Guid;
			Guid.A = 0x48068613;
			Guid.B = 0x749057DA;
			Guid.C = 0x00000000;
			Guid.D = 0x00000000;
			ReturnPackage->SetGuid(Guid);

		}
		return ReturnPackage;
	}
#endif

PRAGMA_ENABLE_DEPRECATION_WARNINGS
